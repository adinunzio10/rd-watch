package com.rdwatch.androidtv.util

import androidx.work.*
import com.rdwatch.androidtv.workers.RealDebridSyncWorker
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.sync.Mutex
import kotlinx.coroutines.sync.withLock
import java.util.concurrent.TimeUnit
import javax.inject.Inject
import javax.inject.Singleton

/**
 * Centralized refresh manager that handles content synchronization
 * 
 * Features:
 * - Debounces multiple refresh requests
 * - Tracks sync status across the app
 * - Manages both manual and automatic refresh
 * - Provides observable sync state
 */
@Singleton
class RefreshManager @Inject constructor(
    private val workManager: WorkManager
) {
    
    // Sync state tracking
    private val _syncState = MutableStateFlow<SyncState>(SyncState.Idle)
    val syncState: StateFlow<SyncState> = _syncState.asStateFlow()
    
    // Debounce mechanism
    private val refreshMutex = Mutex()
    private var lastRefreshTime = 0L
    private val debounceDelayMs = 2000L // 2 seconds
    
    // Work request tracking
    private val _workInfo = MutableStateFlow<WorkInfo?>(null)
    val workInfo: StateFlow<WorkInfo?> = _workInfo.asStateFlow()

    init {
        observeWorkStatus()
    }

    /**
     * Request a manual refresh with debouncing
     */
    suspend fun requestRefresh(force: Boolean = false): Boolean {
        return refreshMutex.withLock {
            val currentTime = System.currentTimeMillis()
            
            if (!force && (currentTime - lastRefreshTime) < debounceDelayMs) {
                // Request is debounced
                false
            } else {
                lastRefreshTime = currentTime
                scheduleImmediateSync()
                true
            }
        }
    }

    /**
     * Schedule periodic sync with WorkManager
     */
    fun schedulePeriodicSync() {
        val periodicWorkRequest = RealDebridSyncWorker.getPeriodicWorkRequest()
        
        workManager.enqueueUniquePeriodicWork(
            RealDebridSyncWorker.WORK_NAME,
            ExistingPeriodicWorkPolicy.KEEP,
            periodicWorkRequest
        )
        
        _syncState.value = SyncState.Scheduled
    }

    /**
     * Schedule immediate one-time sync
     */
    private fun scheduleImmediateSync() {
        val constraints = Constraints.Builder()
            .setRequiredNetworkType(NetworkType.CONNECTED)
            .build()

        val oneTimeWorkRequest = OneTimeWorkRequestBuilder<RealDebridSyncWorker>()
            .setConstraints(constraints)
            .setBackoffCriteria(
                BackoffPolicy.EXPONENTIAL,
                OneTimeWorkRequest.MIN_BACKOFF_DELAY_MILLIS,
                TimeUnit.MILLISECONDS
            )
            .addTag("${RealDebridSyncWorker.WORK_NAME}_manual")
            .build()

        workManager.enqueueUniqueWork(
            "${RealDebridSyncWorker.WORK_NAME}_manual",
            ExistingWorkPolicy.REPLACE,
            oneTimeWorkRequest
        )

        _syncState.value = SyncState.InProgress
    }

    /**
     * Cancel all sync operations
     */
    fun cancelSync() {
        workManager.cancelUniqueWork(RealDebridSyncWorker.WORK_NAME)
        workManager.cancelUniqueWork("${RealDebridSyncWorker.WORK_NAME}_manual")
        _syncState.value = SyncState.Cancelled
    }

    /**
     * Get sync status information
     */
    fun getSyncInfo(): SyncInfo {
        val currentState = _syncState.value
        val lastSyncTime = getLastSuccessfulSyncTime()
        
        return SyncInfo(
            state = currentState,
            lastSyncTime = lastSyncTime,
            isRefreshAvailable = canRefresh()
        )
    }

    /**
     * Check if refresh is currently available (not debounced)
     */
    private fun canRefresh(): Boolean {
        val currentTime = System.currentTimeMillis()
        return (currentTime - lastRefreshTime) >= debounceDelayMs
    }

    /**
     * Observe WorkManager status and update internal state
     */
    private fun observeWorkStatus() {
        // Observe periodic work
        workManager.getWorkInfosForUniqueWorkLiveData(RealDebridSyncWorker.WORK_NAME)
            .observeForever { workInfos ->
                workInfos?.firstOrNull()?.let { workInfo ->
                    _workInfo.value = workInfo
                    updateSyncStateFromWorkInfo(workInfo)
                }
            }

        // Observe manual work
        workManager.getWorkInfosForUniqueWorkLiveData("${RealDebridSyncWorker.WORK_NAME}_manual")
            .observeForever { workInfos ->
                workInfos?.firstOrNull()?.let { workInfo ->
                    updateSyncStateFromWorkInfo(workInfo)
                }
            }
    }

    /**
     * Update sync state based on WorkInfo
     */
    private fun updateSyncStateFromWorkInfo(workInfo: WorkInfo) {
        when (workInfo.state) {
            WorkInfo.State.ENQUEUED -> _syncState.value = SyncState.Scheduled
            WorkInfo.State.RUNNING -> _syncState.value = SyncState.InProgress
            WorkInfo.State.SUCCEEDED -> _syncState.value = SyncState.Success
            WorkInfo.State.FAILED -> _syncState.value = SyncState.Error(
                Exception("Sync failed: ${workInfo.outputData}")
            )
            WorkInfo.State.BLOCKED -> _syncState.value = SyncState.Blocked
            WorkInfo.State.CANCELLED -> _syncState.value = SyncState.Cancelled
        }
    }

    /**
     * Get timestamp of last successful sync
     */
    private fun getLastSuccessfulSyncTime(): Long {
        // This could be persisted in SharedPreferences or DataStore
        // For now, return 0 indicating no previous sync data
        return 0L
    }
}

/**
 * Represents the current sync state
 */
sealed class SyncState {
    object Idle : SyncState()
    object Scheduled : SyncState()
    object InProgress : SyncState()
    object Success : SyncState()
    object Blocked : SyncState()
    object Cancelled : SyncState()
    data class Error(val exception: Exception) : SyncState()
}

/**
 * Information about sync status
 */
data class SyncInfo(
    val state: SyncState,
    val lastSyncTime: Long,
    val isRefreshAvailable: Boolean
)