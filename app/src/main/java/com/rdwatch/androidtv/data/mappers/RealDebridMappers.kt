package com.rdwatch.androidtv.data.mappers

import com.rdwatch.androidtv.data.entities.ContentEntity
import com.rdwatch.androidtv.data.entities.ContentSource
import com.rdwatch.androidtv.network.models.TorrentInfo
import com.rdwatch.androidtv.network.models.UnrestrictLinkResponse
import java.text.SimpleDateFormat
import java.util.*
import kotlin.math.roundToInt

/**
 * Mappers for transforming Real-Debrid API responses to ContentEntity
 */
object RealDebridMappers {
    
    private val dateFormat = SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", Locale.US).apply {
        timeZone = TimeZone.getTimeZone("UTC")
    }
    
    /**
     * Map TorrentInfo from Real-Debrid API to ContentEntity
     */
    fun TorrentInfo.toContentEntity(): ContentEntity {
        val extractedInfo = extractContentInfo(filename)
        
        return ContentEntity(
            id = 0, // Will be auto-generated by Room
            title = extractedInfo.title,
            year = extractedInfo.year,
            quality = extractedInfo.quality,
            source = ContentSource.REAL_DEBRID,
            realDebridId = id, // Store Real-Debrid ID for API operations
            posterUrl = null, // Can be fetched from TMDB later
            backdropUrl = null, // Can be fetched from TMDB later
            description = buildDescription(),
            duration = null, // Not available from torrent info
            rating = null, // Not available from torrent info
            genres = null, // Can be fetched from TMDB later
            cast = null, // Can be fetched from TMDB later
            director = null, // Can be fetched from TMDB later
            imdbId = null, // Can be extracted from filename later
            tmdbId = null, // Can be fetched later
            addedDate = parseDate(added) ?: Date(),
            lastPlayedDate = null,
            playCount = 0,
            isFavorite = false,
            isWatched = status == "downloaded"
        )
    }
    
    /**
     * Map download response from Real-Debrid API to ContentEntity
     * Note: The actual API response for downloads needs to be defined
     */
    fun Map<String, Any>.toContentEntityFromDownload(): ContentEntity {
        val filename = get("filename") as? String ?: "Unknown"
        val downloadId = get("id") as? String
        val extractedInfo = extractContentInfo(filename)
        val filesize = (get("filesize") as? Number)?.toLong() ?: 0L
        val generated = get("generated") as? String
        
        return ContentEntity(
            id = 0, // Will be auto-generated by Room
            title = extractedInfo.title,
            year = extractedInfo.year,
            quality = extractedInfo.quality,
            source = ContentSource.REAL_DEBRID,
            realDebridId = downloadId, // Store Real-Debrid ID for API operations
            posterUrl = null,
            backdropUrl = null,
            description = buildDownloadDescription(filesize),
            duration = null,
            rating = null,
            genres = null,
            cast = null,
            director = null,
            imdbId = null,
            tmdbId = null,
            addedDate = generated?.let { parseDate(it) } ?: Date(),
            lastPlayedDate = null,
            playCount = 0,
            isFavorite = false,
            isWatched = false
        )
    }
    
    /**
     * Extract content information from filename
     */
    private fun extractContentInfo(filename: String): ContentInfo {
        val cleanedName = filename
            .replace(".", " ")
            .replace("_", " ")
            .replace("-", " ")
        
        // Extract year (4 digits between 1900-2099)
        val yearRegex = Regex("""\b(19|20)\d{2}\b""")
        val yearMatch = yearRegex.find(cleanedName)
        val year = yearMatch?.value?.toIntOrNull()
        
        // Extract quality
        val quality = extractQuality(cleanedName)
        
        // Extract title (everything before year or quality indicators)
        val titleEndIndex = listOfNotNull(
            yearMatch?.range?.first,
            quality?.let { cleanedName.indexOf(it, ignoreCase = true).takeIf { idx -> idx >= 0 } }
        ).minOrNull() ?: cleanedName.length
        
        val title = cleanedName.substring(0, titleEndIndex)
            .trim()
            .split(" ")
            .filter { it.isNotBlank() }
            .joinToString(" ")
            .ifBlank { filename }
        
        return ContentInfo(title, year, quality)
    }
    
    /**
     * Extract video quality from filename
     */
    private fun extractQuality(filename: String): String? {
        val qualityPatterns = listOf(
            "2160p", "4K", "UHD",
            "1080p", "FHD", "FullHD",
            "720p", "HD",
            "480p", "SD",
            "360p",
            "HDTV", "WEB-DL", "WEBRip", "BluRay", "BRRip", "DVDRip"
        )
        
        val lowerFilename = filename.lowercase()
        return qualityPatterns.firstOrNull { pattern ->
            lowerFilename.contains(pattern.lowercase())
        }
    }
    
    /**
     * Build description for torrent
     */
    private fun TorrentInfo.buildDescription(): String {
        val parts = mutableListOf<String>()
        
        parts.add("Status: $status")
        parts.add("Size: ${formatFileSize(bytes)}")
        
        progress.let { 
            if (it > 0) parts.add("Progress: ${it.roundToInt()}%")
        }
        
        seeders?.let { 
            if (it > 0) parts.add("Seeders: $it")
        }
        
        speed?.let { 
            if (it > 0) parts.add("Speed: ${formatSpeed(it)}")
        }
        
        // host.let { parts.add("Host: $it") } // Host field not available in TorrentInfo
        
        return parts.joinToString(" â€¢ ")
    }
    
    /**
     * Build description for download
     */
    private fun buildDownloadDescription(filesize: Long): String {
        return "Size: ${formatFileSize(filesize)}"
    }
    
    /**
     * Format file size to human readable format
     */
    private fun formatFileSize(bytes: Long): String {
        val units = arrayOf("B", "KB", "MB", "GB", "TB")
        var size = bytes.toDouble()
        var unitIndex = 0
        
        while (size >= 1024 && unitIndex < units.size - 1) {
            size /= 1024
            unitIndex++
        }
        
        return String.format("%.2f %s", size, units[unitIndex])
    }
    
    /**
     * Format download speed
     */
    private fun formatSpeed(bytesPerSecond: Long): String {
        return "${formatFileSize(bytesPerSecond)}/s"
    }
    
    /**
     * Parse date string to Date object
     */
    private fun parseDate(dateString: String): Date? {
        return try {
            dateFormat.parse(dateString)
        } catch (e: Exception) {
            null
        }
    }
    
    /**
     * Data class to hold extracted content information
     */
    private data class ContentInfo(
        val title: String,
        val year: Int?,
        val quality: String?
    )
}