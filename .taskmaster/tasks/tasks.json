{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Initialize Android TV Project",
        "description": "Set up the Android TV project structure with Jetpack Compose for TV, configure build files, and establish the foundation for rd-watch",
        "details": "Create new Android TV project with minSdk 24 (Android 7.0). Configure build.gradle.kts with Compose for TV dependencies: androidx.tv:tv-compose-foundation:1.0.0-alpha11, androidx.tv:tv-compose-material3:1.0.0-alpha11. Set up Kotlin 1.9.22 with compose compiler 1.5.10. Configure ProGuard rules for release builds. Add buildFeatures { compose = true }. Set up AndroidManifest.xml with TV-specific features: uses-feature android:name=\"android.software.leanback\" android:required=\"true\", uses-feature android:name=\"android.hardware.touchscreen\" android:required=\"false\". Configure TV launcher intent filter.",
        "testStrategy": "Verify project builds successfully, launches on Android TV emulator (API 24+), and displays basic Compose UI. Test D-pad navigation works with focusable composables. Validate AndroidManifest permissions and features are correctly declared.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Android TV project structure",
            "description": "Initialize a new Android project with Android TV support using Android Studio or command line tools",
            "dependencies": [],
            "details": "Create new project with TV activity template, configure package name (e.g., com.example.androidtvapp), set minimum SDK to API 21 (Android TV requirement), target latest stable SDK. Include Kotlin as primary language and enable Jetpack Compose support during project creation.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Configure Gradle build files for TV and Compose",
            "description": "Set up Gradle dependencies and configurations specific to Android TV and Compose for TV",
            "dependencies": [
              1
            ],
            "details": "Add Compose for TV dependencies (androidx.tv:tv-foundation, androidx.tv:tv-material), configure Compose compiler options, add Leanback library dependencies if needed for compatibility. Set up proper build features including compose true, configure ProGuard rules for TV-specific optimizations.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Set up Android TV manifest configurations",
            "description": "Configure AndroidManifest.xml with TV-specific requirements and permissions",
            "dependencies": [
              1
            ],
            "details": "Add android.software.leanback feature declaration (required=true for TV-only, false for multi-platform), declare LEANBACK_LAUNCHER intent filter for main activity, remove touchscreen requirement, add appropriate permissions for TV features. Configure banner icon for TV launcher display.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement initial TV UI scaffolding with Compose",
            "description": "Create basic TV navigation structure and home screen using Compose for TV components",
            "dependencies": [
              2,
              3
            ],
            "details": "Implement TvLazyRow/TvLazyColumn for content browsing, set up focus handling and D-pad navigation support, create basic home screen with content categories. Implement TV-specific theming with appropriate text sizes and spacing for 10-foot UI experience.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Verify build and TV emulator testing",
            "description": "Build the project and test on Android TV emulator to ensure proper setup",
            "dependencies": [
              4
            ],
            "details": "Create Android TV AVD (emulator) with appropriate TV system image, build and deploy the app, verify D-pad navigation works correctly, ensure app appears in TV launcher with proper banner. Test basic UI interactions and focus management on TV interface.\n<info added on 2025-06-22T04:23:13.882Z>\nTesting completed successfully on Android TV emulator (API 34). APK built and deployed successfully to emulator-5554. App launches correctly on Android TV interface with working D-pad navigation (up/down/left/right confirmed). Focus management working properly between UI elements. App appears in TV launcher with leanback launcher integration verified. Basic Compose UI rendering correctly on TV screen. All TV-specific manifest configurations verified including leanback features and permissions. Build system confirmed working with Gradle builds completing successfully. Compose TV UI with proper focus handling validated. D-pad navigation and launcher integration fully functional. Android TV project foundation complete and ready for further development.\n</info added on 2025-06-22T04:23:13.882Z>",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 2,
        "title": "Implement Dependency Injection with Hilt",
        "description": "Set up Hilt for dependency injection across the application, creating modules for network, database, and repository layers",
        "details": "Add Hilt dependencies: com.google.dagger:hilt-android:2.50, androidx.hilt:hilt-navigation-compose:1.1.0. Create @HiltAndroidApp class. Set up DI modules: NetworkModule (provides Retrofit, OkHttp, Moshi instances), DatabaseModule (provides Room database, DAOs), RepositoryModule (binds repository implementations). Configure @Provides methods with proper scoping (@Singleton, @ViewModelScoped). Create qualifiers for different API endpoints. Set up Hilt compiler options in build.gradle. Implement HiltViewModel for ViewModels.",
        "testStrategy": "Write unit tests for DI modules using Hilt testing APIs. Verify all dependencies resolve correctly. Test injection in Activities, ViewModels, and repositories. Use @TestInstallIn to replace modules in tests. Verify no circular dependencies or memory leaks.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up Hilt in the project",
            "description": "Add Hilt dependencies to build.gradle files and configure the Android application class",
            "dependencies": [],
            "details": "Add Hilt Gradle plugin to project-level build.gradle, add Hilt dependencies to app-level build.gradle including hilt-android, hilt-compiler, and hilt-android-testing. Create or update the Application class with @HiltAndroidApp annotation.\n<info added on 2025-06-22T04:46:27.258Z>\nCOMPLETED: Successfully implemented Hilt setup with version 2.50. Added hilt-android and hilt-compiler dependencies to libs.versions.toml version catalog. Configured hilt-android plugin in both project-level and app-level build.gradle files. Created RdWatchApplication class with @HiltAndroidApp annotation in com.rdwatch.androidtv package. Updated AndroidManifest.xml to reference RdWatchApplication as the application class. Verified build passes without errors and Hilt dependency injection framework is now properly initialized and ready for use throughout the project.\n</info added on 2025-06-22T04:46:27.258Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Create Network module with Hilt",
            "description": "Implement Dagger/Hilt module for network layer dependencies including Retrofit, OkHttp, and API services",
            "dependencies": [
              1
            ],
            "details": "Create NetworkModule with @Module and @InstallIn annotations. Provide singleton instances for OkHttpClient with interceptors, Retrofit with converters, and API service interfaces. Use @Provides and @Singleton annotations appropriately.\n<info added on 2025-06-22T04:50:05.406Z>\nImplementation completed with full network layer setup. Added dependencies: Retrofit 2.9.0, OkHttp 4.12.0, Moshi 1.15.0 to libs.versions.toml. NetworkModule created with @Module and @InstallIn(SingletonComponent::class) annotations. Provided singleton instances for HttpLoggingInterceptor with BODY level logging, OkHttpClient with 30s timeouts, Moshi with Kotlin reflection adapter, Retrofit with base URL and Moshi converter, and ApiService interface with movie-related endpoints. All @Provides methods use @Singleton scope. Build verification successful.\n</info added on 2025-06-22T04:50:05.406Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Create Database module with Hilt",
            "description": "Implement Dagger/Hilt module for database layer including Room database, DAOs, and related dependencies",
            "dependencies": [
              1
            ],
            "details": "Create DatabaseModule providing Room database instance, DAOs, and any database-related utilities. Configure Room database builder with proper migrations and type converters. Ensure proper scoping with @Singleton.\n<info added on 2025-06-22T04:53:53.801Z>\nImplementation completed with Room 2.6.1 integration. Enhanced Movie class with @Entity and @PrimaryKey annotations for database mapping. Created MovieDao interface with comprehensive CRUD operations including reactive Flow-based queries for real-time data updates. Implemented AppDatabase as Room database with proper configuration and migration support. Built DatabaseModule with @Module and @InstallIn(SingletonComponent::class) annotations, providing singleton-scoped instances of AppDatabase and MovieDao through Hilt dependency injection. All components properly configured for singleton lifecycle management. Build process verified successfully with no compilation errors.\n</info added on 2025-06-22T04:53:53.801Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Create Repository module with Hilt",
            "description": "Implement Dagger/Hilt module for repository layer that depends on both Network and Database modules",
            "dependencies": [
              2,
              3
            ],
            "details": "Create RepositoryModule that provides repository implementations. Repositories should inject network services and DAOs. Implement proper abstractions with interfaces and concrete implementations. Handle dependency injection for all repository classes.\n<info added on 2025-06-22T04:55:08.917Z>\nImplementation completed successfully. Created comprehensive repository layer with proper abstractions including MovieRepository interface with Flow-based reactive data access patterns. Implemented MovieRepositoryImpl with constructor injection of ApiService and MovieDao following offline-first pattern with network sync capabilities. Added RepositoryModule using @Binds annotation for clean interface-implementation binding. Repository handles both network and local database operations with proper error handling using Result types. Build verification passed with no issues.\n</info added on 2025-06-22T04:55:08.917Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement custom qualifiers and scopes",
            "description": "Create custom qualifiers for distinguishing between similar dependencies and custom scopes if needed",
            "dependencies": [
              1
            ],
            "details": "Define @Qualifier annotations for cases like multiple OkHttpClient instances, different API endpoints, or database configurations. Create custom scopes if needed beyond standard Hilt scopes. Document usage of each qualifier.\n<info added on 2025-06-22T05:19:14.922Z>\nImplementation completed successfully. Created comprehensive custom qualifiers and scopes system for Android TV dependency injection:\n\n**Qualifiers Implementation:**\n- NetworkQualifiers.kt: Implemented @MainApi, @CdnApi, @AnalyticsApi for API endpoint differentiation and @AuthenticatedClient, @PublicClient, @CachingClient for OkHttpClient variants\n- DatabaseQualifiers.kt: Created @MainDatabase, @CacheDatabase, @UserDatabase, @DownloadsDatabase for multi-database architecture\n- RepositoryQualifiers.kt: Added @LocalRepository, @RemoteRepository, @CacheRepository for data layer separation\n\n**Custom Scopes for Android TV:**\n- TvScopes.kt: Implemented @PlaybackScoped, @BrowseScoped, @UserSessionScoped to manage component lifecycles specific to Android TV user experience and navigation patterns\n\n**Module Integration:**\n- Enhanced NetworkModule with multiple OkHttpClient configurations using new qualifiers for authenticated, public, and caching scenarios\n- Updated DatabaseModule with @MainDatabase qualifier for primary Room database instance\n- Created comprehensive documentation in di/README.md with practical usage examples and Android TV-specific best practices\n\n**Verification:**\n- Build verification passed with zero compilation errors\n- All qualifiers properly configured with @Retention(AnnotationRetention.RUNTIME) and @Qualifier annotations\n- Distinct use cases established for each qualifier to prevent injection ambiguity\n- Architecture now supports scalable dependency management for Android TV app complexity\n</info added on 2025-06-22T05:19:14.922Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Configure Hilt testing infrastructure",
            "description": "Set up Hilt testing components including test rules, test modules, and fake implementations",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Add hilt-android-testing dependencies, create HiltTestRunner, configure @HiltAndroidTest for test classes. Create test modules with @TestInstallIn to replace production modules. Implement fake repositories and mock network responses for testing.\n<info added on 2025-06-22T05:24:14.286Z>\nImplementation completed successfully. Comprehensive Hilt testing infrastructure established:\n\n**Dependencies Added:**\n- Updated libs.versions.toml with testing dependencies: JUnit 4.13.2, AndroidX Test libraries, MockK 1.13.8, Coroutines Test 1.8.0\n- Added all testing dependencies to app/build.gradle.kts for both unit and instrumented tests\n\n**Test Infrastructure Components:**\n- HiltTestRunner.kt: Custom test runner for instrumented tests with HiltTestApplication\n- HiltTestBase.kt: Base class for unit tests with Hilt DI setup\n- HiltInstrumentedTestBase.kt: Base class for instrumented tests with Hilt DI\n\n**Test Modules Created:**\n- TestNetworkModule: Replaces NetworkModule with mock APIs and test-friendly configs\n- TestDatabaseModule: Provides in-memory Room database for testing\n- TestRepositoryModule: Mock repository implementations  \n- TestFakeRepositoryModule: Alternative fake implementations for predictable test data\n\n**Test Utilities:**\n- FakeMovieRepository: Full fake implementation with test controls\n- MainDispatcherRule: Coroutine dispatcher management for tests\n- TestConfiguration: Common test constants and utilities\n- Comprehensive test documentation with usage examples\n\n**Configuration:**\n- Updated testInstrumentationRunner to use HiltTestRunner\n- All @TestInstallIn annotations properly configured to replace production modules\n- Build verification in progress (compiling successfully)\n</info added on 2025-06-22T05:24:14.286Z>",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Verify Hilt integration and create sample tests",
            "description": "Validate the complete Hilt setup by creating integration tests and ensuring proper dependency injection",
            "dependencies": [
              6
            ],
            "details": "Write integration tests that verify proper injection in Activities, Fragments, and ViewModels. Test module replacement in test environment. Create unit tests for repositories with injected dependencies. Document any gotchas or best practices discovered.\n<info added on 2025-06-22T05:38:24.183Z>\nImplementation completed successfully with comprehensive test suite covering all aspects of Hilt dependency injection. Created 7 test classes including basic DI verification, module validation, repository testing with both mock and fake implementations, DAO testing with in-memory database, and full integration tests. Established robust testing infrastructure with HiltTestRunner, test modules that automatically replace production modules using @TestInstallIn, and support for both unit and instrumented testing strategies. All Hilt modules properly configured with correct scoping and custom qualifiers validated. Dependency injection graph confirmed free of circular dependencies with annotation processing working correctly throughout build process.\n</info added on 2025-06-22T05:38:24.183Z>",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 3,
        "title": "Design MVVM Architecture Foundation",
        "description": "Establish MVVM architecture patterns with base classes for ViewModels, UI states, and navigation",
        "details": "Create BaseViewModel abstract class extending ViewModel with common functionality: error handling, loading states, coroutine scopes. Implement UiState sealed classes for Success, Loading, Error states. Set up ViewModelFactory with Hilt integration. Create BaseRepository with error handling and network status checking. Implement Resource<T> wrapper for API responses. Set up StateFlow for UI state management. Create extension functions for collecting states in Compose. Implement navigation with androidx.navigation:navigation-compose:2.7.7.",
        "testStrategy": "Test ViewModels with mock repositories, verify state transitions, test error propagation. Use Turbine library for testing Flows. Verify navigation actions trigger correctly. Test memory leaks with LeakCanary.",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create base ViewModel architecture",
            "description": "Implement abstract BaseViewModel class with lifecycle management, coroutine scope handling, and common state management functionality",
            "dependencies": [],
            "details": "Define BaseViewModel extending ViewModel() with protected CoroutineScope, MutableStateFlow for UI state, error handling, and disposable management. Include common functions like launchSafely() for coroutine error handling",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement UI state management pattern",
            "description": "Create sealed classes and data classes for managing UI states including loading, success, error, and empty states",
            "dependencies": [
              1
            ],
            "details": "Define UiState sealed class with Loading, Success<T>, Error, and Empty states. Create ViewState data class pattern for screen-specific states. Implement StateFlow extensions for state observation",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Design repository base pattern",
            "description": "Create BaseRepository interface and implementation with common data operations, error handling, and result wrapping",
            "dependencies": [],
            "details": "Define Repository<T> interface with CRUD operations. Implement Result<T> wrapper for success/failure states. Add NetworkBoundResource pattern for cache-first data loading with remote sync",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Set up navigation architecture",
            "description": "Implement Navigation Component with type-safe navigation, deep linking support, and navigation graph structure",
            "dependencies": [],
            "details": "Configure Navigation Component dependencies, create NavHostFragment setup, define navigation graph XML with global actions. Implement SafeArgs for type-safe argument passing between destinations",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Create centralized error handling",
            "description": "Build comprehensive error handling system with custom exceptions, error mappers, and user-friendly error messages",
            "dependencies": [
              1,
              3
            ],
            "details": "Define AppException hierarchy for domain-specific errors. Create ErrorHandler singleton with error mapping logic. Implement ErrorMessageProvider for localized error messages. Add retry mechanisms for transient failures",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Implement reactive programming setup",
            "description": "Configure RxJava/Kotlin Flow integration with proper schedulers, operators, and lifecycle-aware subscriptions",
            "dependencies": [
              1
            ],
            "details": "Set up Scheduler providers for IO/Main thread switching. Create Flow extensions for common operations. Implement lifecycle-aware collection with repeatOnLifecycle. Add debounce, throttle, and retry operators",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Build dependency injection structure",
            "description": "Configure Hilt/Dagger modules for ViewModels, repositories, and use cases with proper scoping",
            "dependencies": [
              1,
              3,
              4
            ],
            "details": "Create AppModule for singleton dependencies. Set up ViewModelModule with @ViewModelScoped. Configure RepositoryModule with interface bindings. Add NavigationModule for NavController injection",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Create base UI components",
            "description": "Develop reusable base Fragment/Activity classes with common functionality, view binding, and state observation",
            "dependencies": [
              1,
              2,
              4,
              5,
              6
            ],
            "details": "Implement BaseFragment with ViewBinding delegation, state observation helpers, and error handling. Create BaseActivity with navigation setup. Add extension functions for common UI operations like showing loading states",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 4,
        "title": "Configure Network Layer with Retrofit",
        "description": "Set up Retrofit with OkHttp for API communications, including interceptors for authentication and logging",
        "details": "Add dependencies: com.squareup.retrofit2:retrofit:2.9.0, com.squareup.retrofit2:converter-moshi:2.9.0, com.squareup.okhttp3:logging-interceptor:4.12.0. Create RealDebridApi interface with suspend functions for all endpoints. Implement AuthInterceptor for Bearer token injection. Add TokenAuthenticator for automatic token refresh on 401. Configure OkHttpClient with timeouts (30s connect, 60s read/write), connection pooling, certificate pinning for api.real-debrid.com. Add request/response logging interceptor for debug builds. Implement network connectivity interceptor. Set up Moshi with kotlin-codegen for JSON parsing.",
        "testStrategy": "Mock API responses using MockWebServer. Test authentication flow, token refresh, error scenarios. Verify request headers and parameters. Test timeout handling and retry logic. Use Charles Proxy to verify actual API calls.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Add Retrofit dependencies and configure build.gradle",
            "description": "Add Retrofit, OkHttp, and JSON converter dependencies to the project",
            "dependencies": [],
            "details": "Add dependencies for retrofit2:retrofit, retrofit2:converter-gson (or moshi), okhttp3:okhttp, okhttp3:logging-interceptor to build.gradle. Configure ProGuard rules if needed for release builds.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Create base Retrofit configuration and builder",
            "description": "Set up the core Retrofit instance with base URL and client configuration",
            "dependencies": [
              1
            ],
            "details": "Create a RetrofitClient singleton class that builds the Retrofit instance with base URL, timeout configurations, and OkHttpClient. Include connection timeout, read timeout, and write timeout settings.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement authentication interceptor",
            "description": "Create interceptor to handle authentication tokens in API requests",
            "dependencies": [
              2
            ],
            "details": "Build an AuthInterceptor that adds authentication headers (Bearer token, API key, etc.) to outgoing requests. Include token refresh logic if using OAuth2. Handle token storage securely using encrypted SharedPreferences or KeyStore.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Configure logging and monitoring interceptors",
            "description": "Set up request/response logging and performance monitoring",
            "dependencies": [
              2
            ],
            "details": "Implement HttpLoggingInterceptor for debug builds with appropriate log levels. Create custom interceptor for monitoring API performance, response times, and error rates. Ensure sensitive data is not logged in production.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Create API service interfaces",
            "description": "Define Retrofit interfaces for all API endpoints",
            "dependencies": [
              2
            ],
            "details": "Create interface classes with @GET, @POST, @PUT, @DELETE annotations for each API endpoint. Define request/response models using data classes. Group related endpoints into logical service interfaces (UserService, AuthService, etc.).",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Implement error handling and response wrapper",
            "description": "Create unified error handling mechanism for API responses",
            "dependencies": [
              2,
              5
            ],
            "details": "Build a generic ApiResponse wrapper class to handle success/error states. Create custom CallAdapter for automatic error parsing. Implement specific exception classes for different error types (NetworkException, ApiException, AuthException). Handle HTTP error codes appropriately.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Configure JSON parsing with custom serializers",
            "description": "Set up Gson/Moshi configuration with custom type adapters",
            "dependencies": [
              2,
              5
            ],
            "details": "Configure GsonBuilder or Moshi.Builder with custom date formats, null handling policies, and field naming strategies. Create custom TypeAdapters for complex data types. Handle polymorphic JSON structures if needed.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Create comprehensive test suite",
            "description": "Implement unit and integration tests for API configuration",
            "dependencies": [
              3,
              4,
              5,
              6,
              7
            ],
            "details": "Write unit tests for interceptors, error handling, and JSON parsing. Create integration tests using MockWebServer to test full API flows. Test authentication scenarios, error cases, and edge conditions. Implement test fixtures and mock responses.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 5,
        "title": "Implement OAuth2 Device Flow Authentication",
        "description": "Create TV-friendly authentication using Real Debrid's OAuth2 device code flow with QR code display",
        "details": "Implement device code flow: POST /oauth/device/code to get device_code and user_code. Display user_code and verification URL with QR code using com.google.zxing:core:3.5.3. Poll /oauth/device/credentials with device_code at interval specified in response. Handle pending/success/error states. Store tokens securely in EncryptedSharedPreferences. Implement token refresh logic with refresh_token. Create AuthViewModel with states: Initializing, WaitingForUser(code, url), Authenticated, Error. Add countdown timer for code expiration. Generate QR code bitmap for TV display.",
        "testStrategy": "Test full auth flow with mock responses. Verify token storage encryption. Test code expiration handling. Test refresh token flow. Verify error states for network issues, expired codes, denied access. Test on actual TV to verify QR code readability.",
        "priority": "high",
        "dependencies": [
          3,
          4
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up OAuth2 device code request endpoint",
            "description": "Implement the initial device code request to the OAuth2 provider",
            "dependencies": [],
            "details": "Create service to send POST request to OAuth2 device authorization endpoint with client_id and scope parameters. Handle response containing device_code, user_code, verification_uri, and interval values",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Generate and display QR code for authentication URL",
            "description": "Create QR code component that displays the verification URL for mobile scanning",
            "dependencies": [
              1
            ],
            "details": "Use QR code library to generate scannable code from verification_uri. Ensure QR code is TV-optimized with appropriate size and contrast. Include fallback text display of user_code",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement device code polling mechanism",
            "description": "Create background polling service to check authorization status",
            "dependencies": [
              1
            ],
            "details": "Set up interval-based polling using the interval value from device code response. Send POST requests to token endpoint with device_code. Handle authorization_pending, slow_down, and success responses",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Create secure token storage system",
            "description": "Implement secure storage for access and refresh tokens",
            "dependencies": [
              3
            ],
            "details": "Use platform-specific secure storage (KeyChain on tvOS, encrypted preferences on Android TV). Store access_token, refresh_token, and expiry timestamp. Implement encryption for sensitive data",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Build token refresh logic",
            "description": "Implement automatic token refresh mechanism",
            "dependencies": [
              4
            ],
            "details": "Create service to monitor token expiry and refresh tokens before expiration. Handle refresh token rotation if required. Implement retry logic with exponential backoff for failed refreshes",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Design TV-optimized authentication UI states",
            "description": "Create UI components for different authentication flow states",
            "dependencies": [
              2
            ],
            "details": "Design screens for: initial code display, waiting for authorization, success confirmation, and error states. Ensure all UI elements are optimized for 10-foot viewing distance with large fonts and high contrast",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Implement comprehensive error handling",
            "description": "Add error handling for all authentication flow scenarios",
            "dependencies": [
              3,
              5
            ],
            "details": "Handle network errors, expired device codes, invalid grants, rate limiting, and OAuth2 specific errors. Provide user-friendly error messages with TV remote-friendly retry options",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Create authentication state management",
            "description": "Build centralized state management for authentication flow",
            "dependencies": [
              6,
              7
            ],
            "details": "Implement state machine for authentication states: unauthenticated, pending, authenticated, error. Use observable pattern to notify UI of state changes. Persist authentication state across app restarts",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 9,
            "title": "Add remote control navigation support",
            "description": "Ensure authentication flow is fully navigable with TV remote",
            "dependencies": [
              6,
              8
            ],
            "details": "Implement focus management for TV remote D-pad navigation. Add keyboard support for manual code entry fallback. Ensure all interactive elements have clear focus indicators",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 10,
            "title": "Implement authentication flow integration tests",
            "description": "Create comprehensive tests for the complete authentication flow",
            "dependencies": [
              1,
              2,
              3,
              4,
              5,
              7,
              8,
              9
            ],
            "details": "Write unit tests for device code request, polling logic, and token refresh. Create integration tests for complete flow including error scenarios. Add UI tests for remote navigation and state transitions",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 6,
        "title": "Create Room Database Schema",
        "description": "Design and implement Room database for local storage of user data, content metadata, watch history, and scraper configurations",
        "details": "Add androidx.room:room-runtime:2.6.1, androidx.room:room-ktx:2.6.1. Create entities: UserEntity (account info), ContentEntity (movies/shows metadata), WatchProgressEntity (playback positions), LibraryEntity (saved content), ScraperManifestEntity (scraper configs), SearchHistoryEntity, SubtitleSourceEntity. Implement DAOs with Flow returns for reactive updates. Create type converters for complex types (Lists, Dates). Set up database migrations. Configure Room with fallbackToDestructiveMigration for development. Add indices for performance on frequently queried fields. Implement database singleton with proper threading.",
        "testStrategy": "Write instrumented tests for all DAO operations. Test migrations with Migration test rule. Verify Flow emissions on data changes. Test concurrent access scenarios. Profile query performance. Test foreign key constraints.",
        "priority": "high",
        "dependencies": [
          2
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design Core Entity Classes",
            "description": "Create the foundational entity classes for User, Site, Observation, and Model with proper Room annotations",
            "dependencies": [],
            "details": "Define @Entity annotated classes with primary keys, column names, and basic fields. Include @PrimaryKey, @ColumnInfo, and proper data types for each field",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Design Relationship Entity Classes",
            "description": "Create entity classes for junction tables and relationships between core entities",
            "dependencies": [
              1
            ],
            "details": "Implement UserSiteCrossRef, SiteObservationCrossRef, and other junction tables with @Entity annotations and composite primary keys using @Index",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement Type Converters",
            "description": "Create TypeConverter classes for complex data types like Date, JSON objects, and custom enums",
            "dependencies": [
              1
            ],
            "details": "Implement @TypeConverter annotated methods for converting between database-storable types and complex Kotlin/Java types. Include converters for timestamps, coordinate systems, and model configurations",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Create Base DAOs",
            "description": "Implement Data Access Object interfaces for each core entity with basic CRUD operations",
            "dependencies": [
              1,
              2
            ],
            "details": "Define @Dao interfaces with @Insert, @Update, @Delete, and @Query methods. Include suspend functions for coroutine support and return Flow for reactive updates",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement Relationship DAOs",
            "description": "Create DAOs with complex queries handling entity relationships and joins",
            "dependencies": [
              4
            ],
            "details": "Implement @Transaction annotated methods, JOIN queries, and data classes with @Embedded and @Relation annotations for one-to-many and many-to-many relationships",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Setup Database Builder and Configuration",
            "description": "Configure Room database class with proper initialization, versioning, and callback handlers",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Create @Database annotated abstract class, define entity list, version number, and implement singleton pattern. Configure RoomDatabase.Builder with type converters and migration strategies",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Add Database Indices and Optimization",
            "description": "Define indices on frequently queried columns and foreign keys for performance optimization",
            "dependencies": [
              1,
              2
            ],
            "details": "Add @Index annotations to entity classes for columns used in WHERE clauses and JOIN conditions. Create composite indices for multi-column queries and ensure foreign key constraints",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Implement Database Migrations",
            "description": "Create migration classes for database schema versioning and updates",
            "dependencies": [
              6
            ],
            "details": "Implement Migration objects for each schema change, handle ALTER TABLE operations, data transformation during migrations, and fallback strategies. Test migration paths thoroughly",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 9,
            "title": "Create Comprehensive Test Suite",
            "description": "Develop unit and integration tests for entities, DAOs, type converters, and migrations",
            "dependencies": [
              4,
              5,
              8
            ],
            "details": "Write @RunWith(AndroidJUnit4::class) tests using in-memory database, test CRUD operations, relationship queries, migration scenarios, and edge cases. Include performance benchmarks for complex queries",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 7,
        "title": "Build Home Screen with Compose for TV",
        "description": "Create the main home screen with content rows, navigation drawer, and TV-optimized focus handling",
        "details": "Implement home screen using TvLazyColumn and TvLazyRow from tv-compose. Create content rows: Continue Watching (with progress indicators), Recently Added, My Library, Featured Content. Implement TV navigation drawer with tabs: Home, Search, Library, Downloads, Settings. Use ImmersiveList for featured content carousel. Handle D-pad navigation with proper focus management using focusRequester. Implement overscan safe areas. Add loading skeletons with Shimmer effect. Use Coil (io.coil-kt:coil-compose:2.5.0) for image loading with crossfade animations. Implement error states with retry actions.",
        "testStrategy": "Test D-pad navigation flow across all elements. Verify focus restoration on configuration changes. Test with different overscan settings. Profile composable recomposition performance. Test loading states and error handling. Verify accessibility with TalkBack.",
        "priority": "high",
        "dependencies": [
          3,
          6
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up TV navigation drawer structure",
            "description": "Create the base navigation drawer component with TV-specific layout and dimensions",
            "dependencies": [],
            "details": "Implement a navigation drawer that slides in from the left side of the screen. Use TV-safe dimensions (10% padding from edges). Create drawer container with proper z-index layering and backdrop overlay. Set up drawer states (open/closed) and basic structure for menu items.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement TV-optimized content rows",
            "description": "Create horizontal scrollable content rows with lazy loading and virtualization",
            "dependencies": [],
            "details": "Build reusable ContentRow component that supports horizontal scrolling with D-pad navigation. Implement virtualization to render only visible items plus buffer. Add support for different row types (featured, categories, recently watched). Include proper spacing for TV viewing distance.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Add D-pad focus handling system",
            "description": "Implement comprehensive focus management for TV remote navigation",
            "dependencies": [
              1,
              2
            ],
            "details": "Create FocusManager to handle D-pad navigation (up/down/left/right/select). Implement focus trapping within drawer when open. Add visual focus indicators with proper contrast ratios. Handle focus restoration when drawer closes. Implement spatial navigation algorithm for nearest neighbor focus movement.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Integrate progressive image loading",
            "description": "Implement lazy loading system for content thumbnails and posters",
            "dependencies": [
              2
            ],
            "details": "Create ImageLoader component with placeholder support. Implement intersection observer for lazy loading images as they come into viewport. Add low-quality image placeholders (LQIP) for smooth transitions. Include retry logic for failed image loads. Optimize for TV's larger display size with appropriate resolution selection.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Handle loading and error states",
            "description": "Implement comprehensive loading, error, and empty state handling",
            "dependencies": [
              2,
              4
            ],
            "details": "Create loading skeletons for content rows and navigation items. Implement error boundaries for graceful error handling. Add retry mechanisms for failed data fetches. Design empty states for categories with no content. Include loading progress indicators for long-running operations.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Implement overscan safety margins",
            "description": "Ensure all UI elements are within TV-safe viewing area",
            "dependencies": [
              1,
              2
            ],
            "details": "Apply 5-10% safety margins to account for TV overscan. Create SafeAreaProvider component to manage margins across the app. Ensure critical UI elements (navigation, content, controls) are within safe zones. Test on various TV displays and aspect ratios. Implement adjustable overscan settings.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Add smooth animations and transitions",
            "description": "Implement TV-optimized animations for navigation and content transitions",
            "dependencies": [
              1,
              3
            ],
            "details": "Create smooth drawer slide animations with easing curves. Implement focus transition animations with appropriate timing (200-300ms). Add content row scroll animations. Include fade-in effects for lazy-loaded images. Ensure animations run at 60fps on TV hardware.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Ensure comprehensive accessibility",
            "description": "Implement TV-specific accessibility features and screen reader support",
            "dependencies": [
              3,
              7
            ],
            "details": "Add ARIA labels and roles for all interactive elements. Implement announcements for focus changes and navigation. Support high contrast mode for better visibility. Add audio feedback for navigation actions. Ensure proper heading hierarchy for screen readers.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 9,
            "title": "Optimize performance for TV hardware",
            "description": "Ensure smooth performance on various TV processors and memory constraints",
            "dependencies": [
              2,
              4,
              7
            ],
            "details": "Implement aggressive memory management for image caching. Optimize render cycles to prevent frame drops. Use requestAnimationFrame for smooth scrolling. Implement component memoization to prevent unnecessary re-renders. Profile and optimize for low-end TV hardware.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 10,
            "title": "Add keyboard navigation support",
            "description": "Implement full keyboard navigation as fallback for development and testing",
            "dependencies": [
              3,
              8
            ],
            "details": "Map keyboard arrows to D-pad navigation. Add Enter/Space for selection actions. Implement Escape key for back navigation. Add Tab key support for accessibility. Create keyboard shortcut overlay for power users. Ensure consistency between remote and keyboard navigation.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 8,
        "title": "Implement Scraper Manifest System",
        "description": "Create system to load, parse, and manage multiple scraper manifests compatible with Stremio addon format",
        "details": "Create ScraperManifest data model supporting Torrentio/Knightcrawler formats. Implement manifest parser using Moshi with support for: id, name, version, catalogs, resources, types, idPrefixes. Create ScraperRepository to fetch manifests from URLs, validate JSON schema, store in Room database. Implement manifest refreshing with ETag support. Add default scrapers: torrentio.strem.fun, knightcrawler.elfhosted.com. Support configuration extraction (providers[], sorting, quality filters). Create ScraperManager to coordinate multiple scrapers. Handle network errors with exponential backoff.",
        "testStrategy": "Test parsing various manifest formats. Mock manifest endpoints. Test invalid JSON handling. Verify manifest storage and retrieval. Test concurrent manifest loading. Verify configuration parameter extraction. Test manifest update detection.",
        "priority": "high",
        "dependencies": [
          4,
          6
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define Manifest Data Models",
            "description": "Create TypeScript interfaces and classes for manifest data structures",
            "dependencies": [],
            "details": "Define interfaces for Manifest, ManifestEntry, ManifestMetadata, and related types. Include fields for source URLs, scraper configurations, update timestamps, and validation schemas.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement Manifest Parser",
            "description": "Build parser to handle multiple manifest formats (JSON, YAML, XML)",
            "dependencies": [
              1
            ],
            "details": "Create a ManifestParser class with format detection, parsing methods for each supported format, and error handling for malformed data. Use libraries like js-yaml for YAML parsing.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Create Manifest Repository",
            "description": "Implement repository pattern for manifest storage and retrieval",
            "dependencies": [
              1
            ],
            "details": "Build ManifestRepository with methods for CRUD operations, query capabilities, and persistence layer integration. Support both in-memory and database storage backends.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Add Manifest Validation",
            "description": "Implement validation logic for manifest data integrity",
            "dependencies": [
              1,
              2
            ],
            "details": "Create ManifestValidator using JSON Schema or similar validation library. Validate required fields, data types, URL formats, and business rules. Provide detailed validation error messages.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Handle Multiple Format Support",
            "description": "Extend parser to auto-detect and handle various manifest formats",
            "dependencies": [
              2
            ],
            "details": "Implement format detection based on file extensions and content inspection. Add format converters to normalize different formats into unified internal representation.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Implement Manifest Caching",
            "description": "Add caching layer for parsed manifests and remote manifest fetching",
            "dependencies": [
              3
            ],
            "details": "Create ManifestCache with TTL support, cache invalidation strategies, and memory management. Cache both raw manifest data and parsed objects. Support cache warming and preloading.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Create Manifest Manager Class",
            "description": "Build central manager to coordinate manifest operations",
            "dependencies": [
              2,
              3,
              4,
              6
            ],
            "details": "Implement ManifestManager as facade for all manifest operations. Include methods for loading, updating, querying, and synchronizing manifests. Manage manifest lifecycle and dependencies.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Add Comprehensive Error Handling",
            "description": "Implement error handling for all manifest operations",
            "dependencies": [
              7
            ],
            "details": "Create custom error classes for manifest-specific errors. Handle network failures, parsing errors, validation failures, and storage errors. Implement retry logic and fallback strategies.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 9,
            "title": "Setup Default Scrapers Configuration",
            "description": "Configure and integrate default scraper manifests",
            "dependencies": [
              7,
              8
            ],
            "details": "Create default manifest configurations for built-in scrapers. Set up manifest loading during application initialization. Include scraper metadata, scheduling info, and validation rules.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 9,
        "title": "Create Search Interface with Scraper Integration",
        "description": "Build TV-optimized search UI with voice input support and multi-scraper result aggregation",
        "details": "Implement search screen with TV keyboard using ComposeKeyboard or custom D-pad optimized keyboard. Add voice search using SpeechRecognizer API. Create search flow: query  scraper selection  parallel searches  result aggregation. Parse scraper search endpoints from manifests (/stream/movie/{imdb}.json, /stream/series/{imdb}:{season}:{episode}.json). Display results grouped by scraper with source indicators. Show cached status badges. Implement search filters: quality (4K/1080p/720p), cached only, file size ranges. Add search history with Room persistence. Handle rate limiting per scraper.",
        "testStrategy": "Test keyboard navigation and text input. Test voice recognition accuracy. Mock scraper responses. Test result deduplication. Verify filter application. Test search history persistence. Profile search performance with multiple scrapers.",
        "priority": "high",
        "dependencies": [
          7,
          8
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Design TV Keyboard Layout",
            "description": "Create an optimized keyboard layout for TV remote navigation with focus states and D-pad support",
            "dependencies": [],
            "details": "Design a keyboard interface that works well with directional navigation, implementing large touch targets, predictive text zones, and efficient character selection patterns for TV remotes",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement TV Keyboard Component",
            "description": "Build the TV keyboard React component with remote control navigation and text input handling",
            "dependencies": [
              1
            ],
            "details": "Create keyboard component with focus management, directional navigation logic, character selection animations, and text buffer management for TV interface",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Set Up Voice Recognition API",
            "description": "Configure Web Speech API or cloud speech service for voice input on TV platform",
            "dependencies": [],
            "details": "Initialize speech recognition service, handle microphone permissions, configure language models, and implement fallback for unsupported platforms",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Create Voice Search UI",
            "description": "Build voice search interface with visual feedback, waveform display, and transcription preview",
            "dependencies": [
              3
            ],
            "details": "Implement voice button activation, real-time audio visualization, speech-to-text display, and voice command processing with error handling",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Build Search Orchestration Service",
            "description": "Create centralized service to coordinate searches across multiple data sources simultaneously",
            "dependencies": [],
            "details": "Implement parallel search execution, request deduplication, source priority management, and unified query transformation for different APIs",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Implement Result Aggregation Logic",
            "description": "Build system to merge, deduplicate, and rank results from multiple search sources",
            "dependencies": [
              5
            ],
            "details": "Create result normalization, duplicate detection algorithms, relevance scoring, source weighting, and unified result formatting",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Create Search Filter System",
            "description": "Implement filtering capabilities for content type, source, date range, and custom attributes",
            "dependencies": [
              6
            ],
            "details": "Build filter UI components, filter state management, dynamic filter application, and filter persistence across searches",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Implement Rate Limiting",
            "description": "Add rate limiting and request throttling for API calls to prevent quota exhaustion",
            "dependencies": [
              5
            ],
            "details": "Create token bucket implementation, per-source rate limits, request queuing system, and adaptive throttling based on API responses",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 9,
            "title": "Build Search History Feature",
            "description": "Create persistent search history with quick access and search suggestions",
            "dependencies": [
              2,
              4
            ],
            "details": "Implement history storage, recent searches display, search term suggestions, history management UI, and privacy-focused data handling",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 10,
            "title": "Create Search Result Components",
            "description": "Build TV-optimized UI components for displaying search results with rich media previews",
            "dependencies": [
              7
            ],
            "details": "Design result cards, implement lazy loading, create result type-specific layouts, add preview functionality, and optimize for TV viewing distance",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 11,
            "title": "Optimize Search Performance",
            "description": "Implement caching, prefetching, and performance optimizations for smooth TV experience",
            "dependencies": [
              8,
              10
            ],
            "details": "Add result caching layer, implement predictive prefetching, optimize bundle size, reduce render blocking, and ensure 60fps scrolling performance",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 10,
        "title": "Implement Direct Account File Browser",
        "description": "Create interface to browse Real Debrid account files directly, bypassing scraper search",
        "details": "Create dedicated tab/screen for account browsing. Fetch torrents list from /torrents endpoint with pagination. Display files with metadata: name, size, added date, status. Implement sorting: date (newest/oldest), name (A-Z/Z-A), size (largest/smallest). Add filters: file type (video/audio/other), date ranges, size ranges. Create file type detection from extensions. Show storage usage from /user endpoint. Add bulk selection mode for deletion. Implement pull-to-refresh. Cache file list in Room with TTL. Handle large file lists with lazy loading.",
        "testStrategy": "Test pagination with large file lists. Mock API responses for various file types. Test sorting algorithms. Verify filter combinations work correctly. Test deletion confirmations. Test offline cache behavior. Profile performance with 1000+ files.",
        "priority": "medium",
        "dependencies": [
          4,
          7
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Build Content Details Screen",
        "description": "Create detailed view for selected content showing metadata, available sources, and action buttons",
        "details": "Design content details screen with backdrop image, poster, title, year, overview. Integrate TMDb API (themoviedb.org/documentation/api) for rich metadata: cast, crew, ratings, genres, runtime. Display available sources from scrapers with quality badges (4K/HDR/1080p/720p). Show source details: size, seeders, release group, cached status. Add action buttons: Play, Download, Add to Library. For TV shows, display season/episode grid with watched indicators. Implement source selection dialog with smart sorting. Add similar content recommendations section. Handle landscape TV layout with split view.",
        "testStrategy": "Test with movies and TV shows. Verify TMDb data integration. Test source sorting logic. Mock various source scenarios. Test TV show episode navigation. Verify button focus order. Test loading states for metadata fetch.",
        "priority": "medium",
        "dependencies": [
          7,
          9
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Integrate ExoPlayer for Video Playback",
        "description": "Set up ExoPlayer with TV-specific controls and support for various video formats and streaming protocols",
        "details": "Add androidx.media3:media3-exoplayer:1.2.1, androidx.media3:media3-ui:1.2.1. Create custom PlayerView for TV with D-pad controls. Implement playback from Real Debrid unrestricted links. Support formats: MKV, MP4, AVI, WebM with automatic codec detection. Add TV-specific controls: play/pause, seek (10s skip), progress bar with time. Implement subtitle rendering for SRT/VTT/SSA formats. Add audio track selection dialog. Handle 4K/HDR content with proper color space. Create PlayerViewModel for playback state management. Add bandwidth adaptive streaming. Implement playback speed control (0.5x-2.0x).",
        "testStrategy": "Test various video formats and codecs. Test 4K/HDR playback on capable devices. Verify subtitle synchronization. Test audio track switching. Test seek accuracy. Verify memory management during playback. Test network interruption handling.",
        "priority": "high",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Setup ExoPlayer dependency and basic player instance",
            "description": "Add ExoPlayer dependencies to build.gradle and create basic player initialization",
            "dependencies": [],
            "details": "Add ExoPlayer core, UI, and extension dependencies. Create singleton player instance with proper lifecycle management in Application class or dependency injection module.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement custom TV-optimized media controls",
            "description": "Create custom control layout optimized for TV remote navigation with D-pad support",
            "dependencies": [
              1
            ],
            "details": "Design custom PlayerControlView with large, TV-friendly buttons. Implement focus handling, D-pad navigation, and remote control key mapping. Include play/pause, seek, and menu buttons.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Add multi-format media support",
            "description": "Configure ExoPlayer to support various video formats including HLS, DASH, and progressive streams",
            "dependencies": [
              1
            ],
            "details": "Setup MediaSource factories for HLS, DASH, and progressive media. Configure extractors for common formats (MP4, MKV, WebM). Add format detection based on URL or MIME type.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement subtitle rendering system",
            "description": "Add support for embedded and sidecar subtitles with customizable styling",
            "dependencies": [
              1,
              3
            ],
            "details": "Configure SubtitleView with TV-appropriate text size and positioning. Support WebVTT, SRT, and TTML formats. Add subtitle selection UI and style customization options.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Create audio track selection functionality",
            "description": "Implement audio track switching with language detection and selection UI",
            "dependencies": [
              1,
              3
            ],
            "details": "Build track selector for multiple audio streams. Display available languages and formats. Implement seamless audio track switching without playback interruption.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Add HDR and 4K video support",
            "description": "Configure player for high dynamic range and 4K resolution playback",
            "dependencies": [
              1,
              3
            ],
            "details": "Enable HDR10, HDR10+, and Dolby Vision support. Configure surface view for 4K rendering. Add capability detection and fallback for non-HDR displays.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Implement playback state management",
            "description": "Create comprehensive state management for playback position, buffering, and player lifecycle",
            "dependencies": [
              1
            ],
            "details": "Build state machine for player states (idle, buffering, ready, ended, error). Persist playback position across app restarts. Handle configuration changes and background playback.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Setup adaptive streaming with quality selection",
            "description": "Configure adaptive bitrate streaming with manual quality override options",
            "dependencies": [
              3,
              7
            ],
            "details": "Implement ABR algorithm configuration. Create quality selection UI showing available resolutions. Add bandwidth monitoring and quality switching notifications.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 9,
            "title": "Add playback speed controls",
            "description": "Implement variable playback speed with pitch correction",
            "dependencies": [
              2,
              7
            ],
            "details": "Add speed selection UI (0.5x to 2.0x). Configure audio processor for pitch correction. Save user's preferred speed setting per content or globally.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 10,
            "title": "Create comprehensive error handling system",
            "description": "Implement robust error handling with user-friendly messages and recovery options",
            "dependencies": [
              7
            ],
            "details": "Handle network errors, format incompatibility, DRM failures, and decoder errors. Create error UI with retry options. Implement automatic quality downgrade on repeated errors.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 11,
            "title": "Implement advanced seeking and preview thumbnails",
            "description": "Add smooth seeking with thumbnail previews for better navigation",
            "dependencies": [
              2,
              7
            ],
            "details": "Create seek bar with thumbnail preview on hover/focus. Implement frame-accurate seeking. Add chapter markers if available in media metadata.",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 12,
            "title": "Add analytics and performance monitoring",
            "description": "Implement playback analytics and performance metrics collection",
            "dependencies": [
              7,
              10
            ],
            "details": "Track playback events, buffering time, quality switches, and errors. Monitor decoder performance and dropped frames. Create debug overlay for development.",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 13,
        "title": "Implement Playback State Persistence",
        "description": "Create system to track and resume playback positions across sessions with exact timestamp accuracy",
        "details": "Create PlaybackStateRepository to save positions to Room. Track: content ID, current position, total duration, last played timestamp, audio/subtitle track selections. Implement auto-save every 10 seconds during playback. Add resume dialog: 'Resume from X:XX?' with options to start over. For TV shows, track episode completion (>90% watched) and suggest next episode. Create WatchedContentRepository for completion tracking. Implement cleanup for old playback states (>6 months). Sync playback state before app termination. Handle edge cases: very short videos, live streams.",
        "testStrategy": "Test position save accuracy. Verify resume across app restarts. Test episode completion detection. Test next episode suggestions. Verify database cleanup. Test with various video lengths. Mock system kills during playback.",
        "priority": "high",
        "dependencies": [
          6,
          12
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Build Library Management System",
        "description": "Create user library feature for saving and organizing favorite content with categories",
        "details": "Implement library categories: Movies, TV Shows, Currently Watching. Create LibraryViewModel with add/remove operations. Design library screen with grid layout and category filters. Add sort options: recently added, alphabetical, last watched. Implement watched/unwatched indicators using playback completion data. Create quick actions on long-press: Remove from library, Mark as watched, Play next episode. Add library search functionality. Implement library export/import for backup. Cache poster images locally for offline viewing. Add library statistics dashboard.",
        "testStrategy": "Test CRUD operations for library items. Verify category filtering. Test sort algorithms. Test watched status updates. Verify image caching. Test export/import functionality. Test with large libraries (500+ items).",
        "priority": "medium",
        "dependencies": [
          6,
          11
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Implement Smart Episode Progression",
        "description": "Create intelligent system for TV show episode tracking and next episode suggestions",
        "details": "Build episode tracking with season/episode progress. Create NextEpisodeRepository to calculate next unwatched episode. Implement smart detection: if S01E05 completed, suggest S01E06. Handle season boundaries: S01E10  S02E01. Add 'Continue Watching' row on home screen with next episodes. Create episode completion notifications. Handle special episodes (S00) separately. Implement binge mode: auto-play next with 10s countdown. Add episode skip functionality for filler episodes. Create visual season progress indicators. Support custom watch order for anthologies.",
        "testStrategy": "Test episode progression logic with various scenarios. Test season boundary handling. Verify special episode handling. Test binge mode countdown. Test with shows having irregular numbering. Verify progress calculation accuracy. Test skip functionality.",
        "priority": "medium",
        "dependencies": [
          13,
          14
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Create Advanced Source Selection UI",
        "description": "Build sophisticated source picker with quality indicators and smart sorting for optimal stream selection",
        "details": "Design source selection bottom sheet with quality badges: 4K, HDR10, DV, 1080p, 720p. Display source metadata: file size, codec (H.264/H.265), audio format, release group. Implement smart sorting: cached first, then by quality, then by seeders. Add quick filters: Cached only, 4K only, HDR only. Show health indicators: seeder count, availability percentage. Implement source grouping by release type (WEB-DL, BluRay, CAM). Add release group reputation system. Create preview tooltip showing full filename. Handle season pack detection and indication.",
        "testStrategy": "Test with various source combinations. Verify sort algorithm correctness. Test filter combinations. Mock different source scenarios. Test UI performance with 50+ sources. Verify season pack indicators. Test release group sorting.",
        "priority": "medium",
        "dependencies": [
          11
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "Implement External Subtitle Integration",
        "description": "Create subtitle system using free alternatives to OpenSubtitles with hash and name-based matching",
        "details": "Integrate multiple subtitle APIs: Subdl.com (free tier), SubDB (hash-based), Podnapisi.net. Implement hash calculation for video files (first 64KB + last 64KB). Create subtitle search by: file hash, movie/show name + year/season/episode. Build subtitle selection dialog with language filtering. Support formats: SRT, VTT, SSA/ASS. Implement subtitle download and caching in app storage. Add manual subtitle file selection from device storage. Create subtitle synchronization controls (-5s to +5s adjustment). Handle multi-language subtitle tracks. Add subtitle styling options: size, color, background.",
        "testStrategy": "Test hash calculation accuracy. Mock subtitle API responses. Test format parsing (SRT/VTT/SSA). Verify synchronization controls. Test language filtering. Test cache management. Verify manual file loading. Test with non-Latin scripts.",
        "priority": "medium",
        "dependencies": [
          12
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Hash Calculation System Implementation",
            "description": "Implement file hash calculation system for subtitle matching using OpenSubtitles hash algorithm",
            "dependencies": [],
            "details": "Create utility functions to calculate file hashes for movies, implement OpenSubtitles hash algorithm, add hash caching mechanism",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Subdl API Integration",
            "description": "Integrate Subdl API for subtitle search and download functionality",
            "dependencies": [
              1
            ],
            "details": "Implement API client for Subdl service, handle authentication, create search methods for hash-based and name-based queries",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "SubDB API Integration",
            "description": "Integrate SubDB API for subtitle search and download functionality",
            "dependencies": [
              1
            ],
            "details": "Implement API client for SubDB service, handle API rate limiting, create hash-based subtitle search methods",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Podnapisi API Integration",
            "description": "Integrate Podnapisi API for subtitle search and download functionality",
            "dependencies": [
              1
            ],
            "details": "Implement API client for Podnapisi service, handle authentication tokens, create search methods for multiple subtitle formats",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Hash-based Search Implementation",
            "description": "Implement hash-based subtitle search across all integrated APIs",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Create unified search interface using file hashes, implement priority-based API selection, handle search result aggregation",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Name-based Search Implementation",
            "description": "Implement name-based subtitle search as fallback when hash search fails",
            "dependencies": [
              2,
              3,
              4
            ],
            "details": "Create search methods using movie titles and metadata, implement fuzzy matching, handle year and quality filters",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Subtitle Download Management",
            "description": "Implement subtitle download system with progress tracking and error handling",
            "dependencies": [
              5,
              6
            ],
            "details": "Create download manager with retry logic, implement download progress callbacks, handle compressed subtitle files",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Subtitle Cache System",
            "description": "Implement local caching system for downloaded subtitles",
            "dependencies": [
              7
            ],
            "details": "Create cache storage mechanism, implement cache cleanup policies, add cache validation and expiration logic",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 9,
            "title": "Subtitle Format Parsing",
            "description": "Implement parsers for various subtitle formats (SRT, VTT, ASS, SSA)",
            "dependencies": [
              8
            ],
            "details": "Create format detection logic, implement parsers for each format, handle encoding detection and conversion",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 10,
            "title": "Playback Sync Controls",
            "description": "Implement subtitle synchronization controls for playback",
            "dependencies": [
              9
            ],
            "details": "Create sync adjustment UI controls, implement time offset calculations, add real-time sync preview",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 11,
            "title": "Subtitle Styling System",
            "description": "Implement customizable subtitle styling and positioning",
            "dependencies": [
              10
            ],
            "details": "Create style configuration UI, implement font size and color customization, add positioning controls for TV screens",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 12,
            "title": "Manual File Handling",
            "description": "Implement manual subtitle file selection and loading functionality",
            "dependencies": [
              9
            ],
            "details": "Create file browser for subtitle selection, implement drag-and-drop support, add manual file validation",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 13,
            "title": "Error Handling and Recovery",
            "description": "Implement comprehensive error handling and recovery mechanisms across all subtitle features",
            "dependencies": [
              11,
              12
            ],
            "details": "Add error logging and reporting, implement graceful fallbacks, create user-friendly error messages and recovery options",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 18,
        "title": "Build Download Management Interface",
        "description": "Create comprehensive download manager for adding and monitoring Real Debrid transfers",
        "details": "Create download screen with active/completed sections. Implement add torrent flow: paste magnet link or upload .torrent file. Use /torrents/addMagnet and /torrents/addTorrent endpoints. Display file selection for multi-file torrents via /torrents/info. Show real-time progress using polling or WebSocket. Implement download queue management. Add pause/resume/delete actions. Create background service using WorkManager for monitoring. Show system notifications for completion. Add auto-delete option after streaming. Implement download history with search. Add bandwidth limit settings.",
        "testStrategy": "Test magnet link parsing. Test file selection UI. Mock download progress updates. Test background service lifecycle. Verify notification behavior. Test queue management. Test auto-delete functionality. Test with large torrents (50+ files).",
        "priority": "low",
        "dependencies": [
          4,
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "Implement Settings and Preferences",
        "description": "Create comprehensive settings screen for account, playback, and app customization",
        "details": "Build settings with categories: Account (logout, view premium days), Playback (default quality, subtitle preferences, auto-play), Display (theme selection, content layout), Network (bandwidth limits, connection timeout), Storage (clear cache, download location), Scrapers (manage manifests, default scraper). Use DataStore for preference persistence. Implement theme switching: Dark/Light/System. Add playback quality preferences: Prefer 4K, Limit to 1080p, Data saver mode. Create external player selection option. Add parental control PIN system. Implement settings backup/restore.",
        "testStrategy": "Test all preference toggles. Verify DataStore persistence. Test theme switching without restart. Test quality limiting in player. Verify PIN system security. Test settings backup/restore. Test preference migrations.",
        "priority": "medium",
        "dependencies": [
          7
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create preference data models and categories",
            "description": "Define data classes for all preference categories (Account, Playback, Display, Network, Storage, Scrapers) with appropriate default values",
            "dependencies": [],
            "details": "Create sealed classes or enums for preference categories and data classes for each category's settings with proper serialization support",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement DataStore repository layer",
            "description": "Set up DataStore Preference API repository with type-safe preference keys and CRUD operations for all preference categories",
            "dependencies": [
              1
            ],
            "details": "Create PreferencesRepository with methods to read/write preferences using DataStore, handle serialization, and provide reactive data flows",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Build theme system with dynamic switching",
            "description": "Implement comprehensive theme system supporting light/dark modes, custom colors, and runtime theme switching with DataStore persistence",
            "dependencies": [
              2
            ],
            "details": "Create ThemeManager, update Compose theme configuration, implement theme preview functionality, and ensure proper state management",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Create settings UI navigation structure",
            "description": "Build navigation framework for settings screens with category-based organization and Android TV remote control support",
            "dependencies": [
              1
            ],
            "details": "Implement nested navigation graph for settings, create category overview screen, and ensure proper focus management for TV interface",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement Account preferences screen",
            "description": "Build Account settings UI with login/logout functionality, profile management, and sync preferences",
            "dependencies": [
              2,
              4
            ],
            "details": "Create Compose UI for account settings, integrate with authentication system, handle credential storage securely using DataStore",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Implement Playback and Display preferences",
            "description": "Create Playback settings (quality, subtitles, audio) and Display settings (resolution, refresh rate) with player integration",
            "dependencies": [
              2,
              4
            ],
            "details": "Build preference screens for media playback controls, display configuration, integrate with video player, and handle TV-specific display options",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Build Network and Storage preferences",
            "description": "Implement Network settings (connection, proxy, bandwidth) and Storage settings (cache, downloads) with validation",
            "dependencies": [
              2,
              4
            ],
            "details": "Create network configuration UI, storage management interface, implement validation for network settings, and storage cleanup functionality",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Implement Scrapers preferences and parental controls",
            "description": "Build Scrapers configuration screen and comprehensive parental controls with PIN protection and content filtering",
            "dependencies": [
              2,
              4
            ],
            "details": "Create scraper management UI, implement parental control PIN system, content rating filters, and secure storage for parental settings",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 9,
            "title": "Implement backup and restore functionality",
            "description": "Create comprehensive backup/restore system for all preferences with export/import capabilities and cloud sync support",
            "dependencies": [
              2
            ],
            "details": "Build backup manager, implement JSON export/import, create restore UI with selective restoration, and integrate with cloud storage options",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 10,
            "title": "Add preference migration and testing",
            "description": "Implement preference migration system for app updates and create comprehensive testing suite for all preference functionality",
            "dependencies": [
              3,
              5,
              6,
              7,
              8,
              9
            ],
            "details": "Create migration framework for preference schema changes, implement unit tests for DataStore operations, UI tests for settings screens, and integration tests for theme switching",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 20,
        "title": "Create Season Pack Detection System",
        "description": "Build intelligent system to detect and handle multi-episode files from season packs",
        "details": "Implement pattern matching for season pack filenames: 'S01 Complete', 'Season 1', 'S01E01-E10'. Create file analysis to detect multiple episodes in single torrent. Build mapping system: torrent  episodes contained. Store pack information in Room: PackEntity(torrentId, episodes[]). Implement intelligent reuse: if S01E01 uses pack, auto-select same for S01E02. Create UI indicators for pack sources vs single episodes. Handle edge cases: double episodes (S01E01-E02), missing episodes in packs. Add pack preference settings: always prefer packs, ask each time, prefer singles.",
        "testStrategy": "Test filename pattern recognition. Test episode extraction accuracy. Verify pack reuse logic. Test with various naming conventions. Test double episode handling. Mock different pack scenarios. Test preference application.",
        "priority": "low",
        "dependencies": [
          16
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 21,
        "title": "Implement Episode Numbering Inconsistency Handler",
        "description": "Create system to handle shows with problematic episode numbering across different databases",
        "details": "Create show flagging system: users mark shows with numbering issues. Store flags in Room: ProblematicShowEntity(showId, imdbId, preferredDb). Implement multiple episode guide support: query TMDb, TVDb, Trakt APIs for flagged shows. Create episode mapping table: EpisodeMappingEntity(showId, s01e01_tmdb, s01e01_tvdb, s01e01_trakt). Build UI for users to select preferred episode guide per show. Display episode guide source in player UI. Create community mapping submission system. Handle special cases: production order vs air order. Add manual episode progression override for flagged shows.",
        "testStrategy": "Test with known problematic shows (Futurama, etc). Verify API response parsing. Test mapping table accuracy. Test guide switching. Verify manual progression. Test with mock community mappings. Test edge cases for splits/mergers.",
        "priority": "low",
        "dependencies": [
          15
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 22,
        "title": "Build Auto-play with Intelligent Source Selection",
        "description": "Create smart auto-play system that selects optimal sources for next episodes",
        "details": "Implement source ranking algorithm: score = (cached ? 1000 : 0) + (quality_score * 100) + (seeders * 10) + (pack_bonus * 50). Create learning system: track user source selections, adjust weights based on preferences. Build fallback chains: primary source  secondary  tertiary. Implement pre-fetching: resolve next episode source during current playback. Add smart pack reuse: if current episode from pack, use same for next. Create source health monitoring: mark failed sources, skip in future. Add user preferences: quality threshold, release group preferences. Show source selection reasoning in UI.",
        "testStrategy": "Test ranking algorithm with various inputs. Test learning system adaptation. Verify fallback chain execution. Test pre-fetch timing. Test pack reuse logic. Mock source failures. Test preference application. Verify UI reasoning display.",
        "priority": "low",
        "dependencies": [
          15,
          16,
          20
        ],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Design core ranking algorithm architecture",
            "description": "Create the foundational ranking algorithm with scoring mechanisms and weight calculations",
            "dependencies": [],
            "details": "Design a flexible ranking system that can score items based on multiple factors including relevance, performance metrics, user behavior, and contextual signals. Include interfaces for pluggable scoring functions.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Implement feedback learning system",
            "description": "Build a machine learning system that adapts rankings based on user feedback and behavior",
            "dependencies": [
              1
            ],
            "details": "Create a feedback loop that captures user interactions (clicks, dwell time, conversions) and updates ranking weights. Implement online learning algorithms to continuously improve rankings.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Create intelligent fallback chains",
            "description": "Develop a system for graceful degradation when primary ranking methods fail",
            "dependencies": [
              1
            ],
            "details": "Build fallback mechanisms that activate when primary rankers are unavailable or underperforming. Include rule-based fallbacks, cached results, and simplified ranking algorithms.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Implement predictive pre-fetching",
            "description": "Add intelligent pre-fetching to anticipate user needs and improve response times",
            "dependencies": [
              1,
              2
            ],
            "details": "Create a prediction system that pre-computes rankings for likely queries based on user patterns, temporal trends, and contextual signals. Include cache warming strategies.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Build result pack reuse system",
            "description": "Implement efficient reuse of previously computed ranking results",
            "dependencies": [
              1,
              4
            ],
            "details": "Design a caching layer that intelligently stores and reuses ranking results. Include similarity detection to identify when cached results can be adapted for new queries.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Add comprehensive health monitoring",
            "description": "Create monitoring systems to track ranking algorithm performance and health",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Implement real-time monitoring of ranking quality metrics, latency, error rates, and model drift. Include alerting for anomalies and automatic circuit breakers.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Integrate user preference system",
            "description": "Build personalization capabilities into the ranking algorithm",
            "dependencies": [
              1,
              2
            ],
            "details": "Create user profile management that captures preferences, historical behavior, and context. Integrate personalization signals into ranking calculations while maintaining privacy.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Create ranking reasoning UI",
            "description": "Develop user interface components that explain ranking decisions",
            "dependencies": [
              1,
              7
            ],
            "details": "Build UI elements that show why items are ranked as they are, including contributing factors and weights. Provide interactive controls for users to adjust preferences.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 9,
            "title": "Optimize algorithm performance",
            "description": "Enhance ranking speed and efficiency through various optimization techniques",
            "dependencies": [
              1,
              2,
              4,
              5
            ],
            "details": "Implement performance optimizations including vectorization, parallel processing, approximate algorithms, and efficient data structures. Target sub-100ms latency.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 10,
            "title": "Implement A/B testing framework",
            "description": "Build infrastructure for testing ranking algorithm variations",
            "dependencies": [
              1,
              2,
              6
            ],
            "details": "Create a framework for running controlled experiments on ranking algorithms. Include traffic splitting, metric collection, and statistical analysis capabilities.",
            "status": "pending",
            "testStrategy": ""
          },
          {
            "id": 11,
            "title": "Create ranking quality metrics",
            "description": "Develop comprehensive metrics to measure and track ranking effectiveness",
            "dependencies": [
              1,
              2,
              6,
              10
            ],
            "details": "Implement metrics for relevance (NDCG, MAP), user satisfaction (CTR, dwell time), diversity, freshness, and fairness. Build dashboards for monitoring these metrics.",
            "status": "pending",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 23,
        "title": "Implement Voice Search and Commands",
        "description": "Add voice control for search and playback commands using Android TV voice APIs",
        "details": "Integrate Android TV SearchManager for voice search. Implement voice command recognition: 'Play [movie name]', 'Search for [content]', 'Next episode', 'Pause/Resume'. Create VoiceSearchActivity to handle ACTION_SEARCH intents. Add continuous listening mode during playback for commands. Implement natural language processing for queries: 'Show me action movies', 'Find 4K content'. Add voice feedback using TextToSpeech. Support multiple languages based on system locale. Create custom voice command training UI. Handle ambiguous results with voice-guided selection.",
        "testStrategy": "Test voice recognition accuracy. Test command parsing. Verify search intent handling. Test with different accents/languages. Test continuous listening battery impact. Mock voice input for automated tests. Test ambiguous query handling.",
        "priority": "low",
        "dependencies": [
          9
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 24,
        "title": "Create Android TV Recommendations",
        "description": "Implement Android TV home screen recommendations using Leanback recommendation system",
        "details": "Implement TvRecommendationService using androidx.tvprovider. Create recommendation channels: Continue Watching, New Episodes, Trending. Build RecommendationBuilder with content metadata and images. Update recommendations using WorkManager periodic tasks. Implement click handling to deep-link into app. Add recommendation preferences: enable/disable, update frequency. Create smart recommendations based on watch history. Handle recommendation limits (max 100 per channel). Add notification channel for recommendations. Implement recommendation analytics tracking.",
        "testStrategy": "Test recommendation display on launcher. Verify deep-link handling. Test update frequency. Test with maximum recommendations. Verify image loading. Test preference controls. Mock system recommendation limits. Test analytics events.",
        "priority": "low",
        "dependencies": [
          14,
          15
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 25,
        "title": "Optimize Performance and Polish UI",
        "description": "Fine-tune app performance, add animations, and polish the overall user experience",
        "details": "Profile app with Android Studio Profiler, identify bottlenecks. Optimize image loading: implement progressive loading, memory cache limits. Add Baseline Profiles for faster startup. Implement smooth animations: shared element transitions, parallax effects on scroll. Optimize database queries with proper indices. Add app shortcuts for quick actions. Implement proper error boundaries with fallback UI. Add loading state skeletons throughout. Optimize recomposition with derivedStateOf and remember. Implement proper focus restoration. Add haptic feedback for D-pad actions. Create onboarding flow for first-time users.",
        "testStrategy": "Measure startup time (<3s target). Profile memory usage (<200MB). Test on low-end devices (Fire TV Stick Lite). Verify animation smoothness (60fps). Test with slow network conditions. Use Macrobenchmark for performance testing. Test focus restoration scenarios.",
        "priority": "low",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          16,
          17,
          18,
          19,
          20,
          21,
          22,
          23,
          24
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 26,
        "title": "Fix Navigation System Integration",
        "description": "Wire MainActivity to use AppNavigation system instead of bypassing it, replacing direct TVHomeScreen() call with NavHost setup and implementing proper navigation between screens.",
        "details": "Replace the direct TVHomeScreen() call in MainActivity with proper NavHost setup using Compose Navigation. Uncomment and configure navigation destinations in AppNavigation.kt including Home, Search, Library, Downloads, and Settings screens. Implement click handlers in navigation drawer and menu items to actually navigate between screens using NavController. Set up proper navigation graph with startDestination pointing to home screen. Configure navigation animations suitable for TV (slide transitions). Implement back stack management for TV navigation patterns. Add proper focus management when navigating between screens to ensure D-pad navigation works correctly. Create NavigationViewModel to handle navigation state and deep linking. Ensure all navigation actions use the centralized navigation system rather than direct screen calls. Configure proper argument passing between screens for content details navigation.",
        "testStrategy": "Test navigation flow between all screens using D-pad controls. Verify proper focus restoration when returning to previous screens. Test back button navigation and back stack management. Verify navigation drawer opens and closes correctly with menu selections working. Test deep linking to specific screens. Verify no direct screen instantiation bypasses the navigation system. Test navigation state persistence across configuration changes. Verify proper animation transitions between screens on TV devices.",
        "status": "done",
        "dependencies": [
          7,
          3
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Set up NavHost in MainActivity",
            "description": "Configure NavHost with NavController in MainActivity.kt using Jetpack Compose Navigation",
            "dependencies": [],
            "details": "Add NavHost composable to MainActivity, initialize NavController, and set up basic navigation container structure",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Configure navigation graph with screens",
            "description": "Define navigation graph with all app screens and their routes",
            "dependencies": [
              1
            ],
            "details": "Create navigation graph defining routes for home, movie details, settings, and other screens with proper composable destinations",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement navigation handler functions",
            "description": "Create navigation handler functions for screen transitions and parameter passing",
            "dependencies": [
              2
            ],
            "details": "Implement navigation handlers for moving between screens, passing movie data, and handling navigation events",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Integrate focus management with navigation",
            "description": "Set up focus management system to work with navigation transitions",
            "dependencies": [
              3
            ],
            "details": "Ensure proper focus handling during navigation, focus restoration, and TV remote navigation behavior",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Configure deep linking support",
            "description": "Set up deep linking for direct navigation to specific screens",
            "dependencies": [
              2
            ],
            "details": "Implement deep link handling for movie details and other screens with proper URI patterns",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Configure back stack management",
            "description": "Set up proper back stack behavior for TV navigation patterns",
            "dependencies": [
              4,
              5
            ],
            "details": "Configure back stack behavior, handle back button presses, and implement TV-appropriate navigation patterns",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 27,
        "title": "Implement Missing Click Handlers and User Interactions",
        "description": "Replace all TODO click handlers in HomeScreen, ContentRow, and other UI components with actual navigation and functionality to enable basic user interaction.",
        "details": "Replace placeholder click handlers throughout the UI components. In HomeScreen.kt, implement movie card click navigation to detail screen using NavController. In ContentRow.kt, add movie selection logic that updates selected state and triggers detail view. Implement resume dialog navigation from continue watching cards - check playback state and show resume/restart options. Add focus handling for TV remote navigation using Modifier.focusable() and onFocusChanged. Create MovieDetailViewModel to handle movie selection state. Implement deep-link handling for recommendations and external navigation. Add haptic feedback for button presses using LocalHapticFeedback. Handle loading states during navigation transitions. Implement back navigation handling and proper fragment/screen stack management. Add click animations and visual feedback for better UX. Create proper error handling for failed navigation attempts.",
        "testStrategy": "Test all click handlers respond correctly on Android TV emulator with remote. Verify movie cards navigate to detail screen with correct movie data. Test resume dialog shows when clicking continue watching items. Test focus navigation works properly with D-pad controls. Verify back button navigation maintains proper screen stack. Test deep-link handling from Android TV launcher recommendations. Test loading states during navigation transitions. Verify error handling for network failures during navigation. Test with physical Android TV remote control. Test accessibility navigation with TalkBack enabled.",
        "status": "done",
        "dependencies": [
          13,
          19
        ],
        "priority": "high",
        "subtasks": []
      },
      {
        "id": 28,
        "title": "Create Missing Core Screens",
        "description": "Implement basic versions of BrowseScreen, SettingsScreen, MovieDetailsScreen, and ProfileScreen that are referenced in navigation but don't exist yet.",
        "details": "Create four core screen composables with stub implementations:\n\n1. **BrowseScreen**: Main content discovery screen with grid layout for movies/shows. Add search bar, category filters (Movies, TV Shows, Trending). Include basic content grid using LazyVerticalGrid with placeholder cards. Implement navigation to MovieDetailsScreen on item click.\n\n2. **SettingsScreen**: App configuration screen with preference sections. Include Real Debrid account settings, playback preferences, subtitle options, and app theme selection. Use PreferenceCategory composables for organization. Add logout functionality and account status display.\n\n3. **MovieDetailsScreen**: Content detail view with poster, synopsis, cast info, and play button. Display metadata like runtime, genre, release date. Include trailer preview section and related content recommendations. Add library management buttons (Add to Library, Mark as Watched).\n\n4. **ProfileScreen**: User account overview with watch history, library statistics, and account management. Show Recently Watched section, Library summary (total movies/shows), and Real Debrid account info. Include quick access to downloaded content.\n\nEach screen should use Jetpack Compose with proper theming, handle loading states, and include basic error handling. Implement proper navigation arguments where needed (MovieDetailsScreen requires content ID). Add basic UI tests for each screen.",
        "testStrategy": "Test navigation to each screen without crashes. Verify proper theme application and UI responsiveness on TV screens. Test MovieDetailsScreen with valid content ID parameter. Verify SettingsScreen preference interactions. Test BrowseScreen grid layout with mock data. Ensure ProfileScreen displays placeholder content correctly. Test back navigation from all screens. Verify proper focus handling for TV remote navigation on each screen.",
        "status": "done",
        "dependencies": [
          6
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Create BrowseScreen with basic layout",
            "description": "Create BrowseScreen composable with basic Jetpack Compose layout optimized for Android TV navigation",
            "dependencies": [],
            "details": "Implement BrowseScreen using Compose with TV-specific focus handling, grid layout for content browsing, and proper remote control navigation support",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Create SettingsScreen with basic layout",
            "description": "Create SettingsScreen composable with settings options layout for Android TV",
            "dependencies": [],
            "details": "Implement SettingsScreen with TV-friendly settings UI, focus management, and basic settings categories layout",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Create MovieDetailsScreen with basic layout",
            "description": "Create MovieDetailsScreen composable to display detailed movie information",
            "dependencies": [],
            "details": "Implement MovieDetailsScreen with movie poster, title, description, and action buttons optimized for TV viewing experience",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Create ProfileScreen with basic layout",
            "description": "Create ProfileScreen composable with user profile information layout",
            "dependencies": [],
            "details": "Implement ProfileScreen with user avatar, profile information, and account settings optimized for TV navigation",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Create ViewModels for each screen",
            "description": "Implement ViewModel classes for BrowseScreen, SettingsScreen, MovieDetailsScreen, and ProfileScreen",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Create ViewModels following MVVM pattern with proper state management, data handling, and lifecycle awareness for each screen",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Implement navigation integration",
            "description": "Set up Jetpack Navigation Compose to connect all screens with proper TV navigation",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Configure NavHost, define navigation routes, implement screen transitions, and ensure proper back navigation handling for TV remote control",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Add placeholder content to BrowseScreen",
            "description": "Populate BrowseScreen with placeholder movie data and content categories",
            "dependencies": [
              1,
              5
            ],
            "details": "Add sample movie data, create content categories, implement grid layout with placeholder images and titles",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Add placeholder content to other screens",
            "description": "Populate SettingsScreen, MovieDetailsScreen, and ProfileScreen with placeholder content",
            "dependencies": [
              2,
              3,
              4,
              5
            ],
            "details": "Add sample settings options, movie details placeholder data, and profile information placeholders",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 9,
            "title": "Apply proper theming to all screens",
            "description": "Ensure all screens use consistent Material3 theming optimized for TV displays",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Apply TV-appropriate colors, typography, and spacing from existing theme configuration to all screen components",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 10,
            "title": "Test navigation and focus handling",
            "description": "Verify proper navigation flow and remote control focus handling across all screens",
            "dependencies": [
              6,
              7,
              8,
              9
            ],
            "details": "Test remote control navigation, focus management, screen transitions, and ensure proper TV UX patterns are followed",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 29,
        "title": "Integrate OAuth Authentication into App Flow",
        "description": "Connect the completed OAuth system to app startup sequence, add authentication state checks, create sign-in entry points, and implement post-authentication routing to make OAuth actually usable.",
        "details": "Modify MainActivity to check authentication state on startup using AuthViewModel. Add authentication state flow observation to redirect unauthenticated users to sign-in screen. Create sign-in entry points in navigation menu and settings screen. Implement AuthenticationScreen composable that displays OAuth flow UI with device code and QR code. Add authenticated/unauthenticated navigation graph states using Compose Navigation. Create post-authentication routing logic to redirect users to their intended destination or default browse screen. Implement sign-out functionality in settings with token cleanup. Add authentication state persistence across app restarts using stored tokens. Create loading states during token validation on app startup. Handle edge cases: expired tokens during app use, network failures during auth check, interrupted OAuth flow. Add proper error handling with user-friendly messages for authentication failures.",
        "testStrategy": "Test app startup with no stored tokens redirects to sign-in. Verify successful OAuth flow navigates to browse screen. Test token expiration during app use triggers re-authentication. Verify sign-out clears tokens and navigates to sign-in. Test network failures during startup auth check. Verify deep linking works after authentication. Test app restart maintains authentication state. Verify all navigation entry points respect authentication state. Test interrupted OAuth flow recovery.",
        "status": "done",
        "dependencies": [
          5,
          28
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Authentication State Management",
            "description": "Implement centralized authentication state management with token storage and validation",
            "dependencies": [],
            "details": "Create AuthManager or similar class to handle authentication state, token persistence using SharedPreferences or DataStore, and provide methods for checking authentication status",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "Design Authentication UI Screen",
            "description": "Create OAuth authentication screen with TV-optimized UI using Jetpack Compose",
            "dependencies": [],
            "details": "Build authentication screen with proper focus handling for TV remote navigation, OAuth login button, loading states, and error display components",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Implement Startup Authentication Check",
            "description": "Add authentication verification during app startup with appropriate routing",
            "dependencies": [
              1
            ],
            "details": "Modify MainActivity or create splash screen to check authentication status on startup and route users to appropriate screen based on authentication state",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Create Navigation Graph with Auth States",
            "description": "Set up navigation system to handle authenticated and unauthenticated user flows",
            "dependencies": [
              2,
              3
            ],
            "details": "Configure Jetpack Navigation with conditional navigation graphs, authenticated routes, and unauthenticated routes with proper back stack management",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Implement Token Management System",
            "description": "Create secure token storage, refresh logic, and expiration handling",
            "dependencies": [
              1
            ],
            "details": "Build token refresh mechanism, secure storage implementation, automatic token renewal, and token expiration detection with appropriate user notifications",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Add Sign-Out Functionality",
            "description": "Create sign-out feature with proper cleanup and navigation",
            "dependencies": [
              1,
              4,
              5
            ],
            "details": "Implement sign-out button in appropriate UI locations, clear stored tokens and user data, reset navigation state to unauthenticated flow",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Implement Authentication Error Handling",
            "description": "Create comprehensive error handling for various authentication failure scenarios",
            "dependencies": [
              2,
              5
            ],
            "details": "Handle network errors, invalid tokens, expired sessions, OAuth failures, and server errors with appropriate user feedback and recovery options",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Handle Edge Cases and Testing",
            "description": "Address edge cases like offline scenarios, concurrent sessions, and app backgrounding",
            "dependencies": [
              1,
              3,
              4,
              5,
              6,
              7
            ],
            "details": "Handle app backgrounding during auth flow, offline authentication checks, multiple device sessions, and create comprehensive test coverage for authentication scenarios",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 9,
            "title": "Implement startup authentication check",
            "description": "Create authentication state verification on app startup to determine initial navigation flow",
            "dependencies": [],
            "details": "Add authentication state check in MainActivity or application startup to verify if user has valid token and determine whether to show auth screen or main content",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 10,
            "title": "Design authentication UI screen",
            "description": "Create Compose-based authentication screen for OAuth login flow",
            "dependencies": [],
            "details": "Build authentication screen using Jetpack Compose with appropriate styling for Android TV, including OAuth login button and loading states",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 11,
            "title": "Implement navigation graph states",
            "description": "Setup navigation graph to handle authenticated and unauthenticated user states",
            "dependencies": [
              9,
              10
            ],
            "details": "Configure Compose Navigation to have separate navigation graphs or conditional routing based on authentication state, ensuring proper flow between auth and main screens",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 12,
            "title": "Implement token management system",
            "description": "Create secure token storage and management for OAuth authentication",
            "dependencies": [],
            "details": "Implement secure storage for OAuth tokens using EncryptedSharedPreferences or similar, including token refresh logic and validation",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 13,
            "title": "Add sign-out functionality",
            "description": "Implement user sign-out with proper token cleanup and navigation reset",
            "dependencies": [
              11,
              12
            ],
            "details": "Create sign-out functionality that clears stored tokens, resets authentication state, and navigates user back to authentication screen",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 14,
            "title": "Implement authentication error handling",
            "description": "Add comprehensive error handling for authentication failures and network issues",
            "dependencies": [
              10,
              12
            ],
            "details": "Handle various authentication error scenarios including network failures, invalid tokens, expired sessions, and OAuth provider errors with appropriate user feedback",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 15,
            "title": "Handle authentication edge cases",
            "description": "Implement handling for edge cases like token expiration during app use and offline scenarios",
            "dependencies": [
              12,
              13,
              14
            ],
            "details": "Handle edge cases such as token expiration while app is running, network connectivity issues, and graceful degradation when authentication services are unavailable",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 16,
            "title": "Integrate authentication flow with existing app navigation",
            "description": "Connect authentication system with existing app navigation and ensure smooth user experience",
            "dependencies": [
              11,
              13,
              15
            ],
            "details": "Ensure authentication flow integrates seamlessly with existing MainActivity and navigation system, maintaining proper state across app lifecycle events",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 30,
        "title": "Replace Mock Data with Real-Debrid API Integration",
        "description": "Connect UI components to actual Real-Debrid API data instead of hardcoded MovieList.MOCK_DATA. Update repositories to fetch real data, populate database from API responses, connect ViewModels to real data sources.",
        "details": "Replace MovieList.MOCK_DATA usage throughout the application with Real-Debrid API calls. Create ContentRepository that fetches movie/TV show data from Real-Debrid user library, torrents, and downloads endpoints. Implement data transformation from Real-Debrid API responses to local ContentEntity models. Update MovieRepository to use RealDebridApi service instead of static data. Create data synchronization logic to populate Room database from API responses with proper error handling and offline caching. Modify ViewModels (HomeViewModel, BrowseViewModel, etc.) to use repository Flow emissions instead of static lists. Implement refresh mechanisms with SwipeRefresh or pull-to-refresh patterns. Add loading states and error handling for network failures. Create data mapping functions to transform Real-Debrid torrent info, user library items, and download status into app's content models. Set up periodic background sync using WorkManager to keep local data fresh. Handle pagination for large content libraries and implement incremental loading for better performance.",
        "testStrategy": "Test API integration with actual Real-Debrid account and verify data flows correctly to UI. Mock Real-Debrid API responses to test various data scenarios including empty libraries, failed requests, and large datasets. Verify database population from API responses with proper entity relationships. Test offline functionality when API is unavailable - app should display cached data. Test loading states and error handling for network timeouts and API errors. Verify ViewModels emit correct data states and UI updates reactively. Test data refresh mechanisms and verify stale data is properly updated. Use integration tests to verify complete data flow from API to UI components. Test pagination and incremental loading with large content libraries. Verify background sync works correctly and doesn't impact app performance.",
        "status": "done",
        "dependencies": [
          4,
          6,
          8,
          29
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Repository Updates",
            "description": "Update repository layer to integrate with real API endpoints instead of mock data",
            "dependencies": [],
            "details": "Modify existing repository classes to make HTTP requests to actual API endpoints, remove mock data generation, and implement proper API client configuration",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 2,
            "title": "API Data Transformation",
            "description": "Implement data transformation layer to convert API responses to domain models",
            "dependencies": [
              1
            ],
            "details": "Create data mappers and DTOs to transform raw API responses into the existing Movie data model, handle nested objects and optional fields",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Room Database Population",
            "description": "Set up Room database entities and DAOs for local data storage",
            "dependencies": [
              2
            ],
            "details": "Create Room database schema, entities matching the Movie model, DAOs for CRUD operations, and database migration strategies",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "ViewModel Modifications",
            "description": "Update ViewModels to work with repository and handle API data flow",
            "dependencies": [
              3
            ],
            "details": "Modify existing ViewModels to consume data from repository layer, manage loading states, and handle data binding with Compose UI",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Refresh Mechanisms",
            "description": "Implement pull-to-refresh and manual refresh functionality",
            "dependencies": [
              4
            ],
            "details": "Add swipe-to-refresh gestures for Android TV remote navigation, implement manual refresh buttons, and coordinate refresh operations across components",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 6,
            "title": "Error Handling",
            "description": "Implement comprehensive error handling for API failures and network issues",
            "dependencies": [
              2
            ],
            "details": "Create error handling strategies for network failures, API errors, data parsing errors, and user-friendly error messages with retry mechanisms",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 7,
            "title": "Pagination Implementation",
            "description": "Add pagination support for large datasets from API",
            "dependencies": [
              2,
              6
            ],
            "details": "Implement pagination logic in repository layer, create infinite scroll for Android TV navigation, and manage page loading states",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 8,
            "title": "Background Sync Setup",
            "description": "Configure background synchronization using WorkManager",
            "dependencies": [
              3,
              6
            ],
            "details": "Set up WorkManager for periodic data sync, handle sync conflicts, implement sync status indicators, and configure sync policies",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 9,
            "title": "Performance Optimization",
            "description": "Optimize data loading and caching for large datasets",
            "dependencies": [
              7,
              8
            ],
            "details": "Implement efficient caching strategies, optimize database queries, add data prefetching, and minimize memory usage during data operations",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 10,
            "title": "Testing Integration",
            "description": "Create tests for API integration and data flow",
            "dependencies": [
              9
            ],
            "details": "Write unit tests for repository layer, integration tests for API calls, database tests, and UI tests for data loading scenarios",
            "status": "done",
            "testStrategy": ""
          },
          {
            "id": 11,
            "title": "Documentation and Cleanup",
            "description": "Update documentation and remove obsolete mock data code",
            "dependencies": [
              10
            ],
            "details": "Update CLAUDE-architecture.md with new data flow, clean up mock data files, document API integration patterns, and update development setup instructions",
            "status": "done",
            "testStrategy": ""
          }
        ]
      },
      {
        "id": 31,
        "title": "Integrate Scraper System with Settings UI",
        "description": "Connect the existing scraper implementation to the user interface by adding a comprehensive scraper settings section to the Settings screen with configuration and management capabilities.",
        "details": "Create ScraperSettingsScreen composable within the Settings navigation flow. Build ScraperSettingsViewModel to manage scraper state and user interactions. Implement scraper list display showing active scrapers with status indicators (enabled/disabled, last updated, error states). Add scraper management actions: enable/disable toggle, remove scraper, refresh manifest. Create AddScraperDialog for adding new scrapers via URL input with validation. Implement scraper configuration UI for each scraper's specific settings (quality filters, providers, sorting preferences). Add ScraperStatusCard component showing scraper health, response times, and available content count. Create scraper preferences section: default quality selection, preferred providers, auto-refresh settings. Integrate with existing ScraperRepository and ScraperManifestEntity from the database layer. Handle loading states, error messages, and success confirmations with proper TV navigation focus management. Add confirmation dialogs for destructive actions like removing scrapers. Implement settings persistence and real-time updates when scraper configurations change.",
        "testStrategy": "Test scraper list display with various scraper states (active, disabled, error). Verify add scraper flow with valid and invalid URLs. Test scraper removal with confirmation dialog. Verify configuration changes persist correctly. Test enable/disable toggle functionality. Mock scraper repository responses for different scenarios. Test navigation focus flow between settings components. Verify loading states during manifest refresh operations. Test error handling for network failures and invalid manifests. Test settings screen integration with main navigation flow.",
        "status": "done",
        "dependencies": [
          8,
          6,
          2
        ],
        "priority": "high",
        "subtasks": [
          {
            "id": 1,
            "title": "Create ScraperSettingsScreen and Navigation",
            "description": "Build the main ScraperSettingsScreen composable and integrate it into the Settings navigation flow with proper TV focus handling",
            "dependencies": [],
            "details": "Create ScraperSettingsScreen.kt in app/src/main/java/com/rdwatch/androidtv/ui/settings/scraper/. Add navigation route in SettingsNavigation.kt. Implement basic screen layout with LazyColumn for TV, proper focus management using TvLazyColumn, and back navigation handling. Set up screen state management and loading indicators.",
            "status": "done",
            "testStrategy": "Create UI tests to verify navigation to scraper settings, focus traversal with D-pad, and back button functionality"
          },
          {
            "id": 2,
            "title": "Implement ScraperSettingsViewModel",
            "description": "Create ViewModel to manage scraper state, handle user interactions, and communicate with ScraperRepository",
            "dependencies": [],
            "details": "Create ScraperSettingsViewModel.kt extending ViewModel. Implement StateFlow for UI state management including scraper list, loading states, and error messages. Add functions for scraper operations: enableScraper(), disableScraper(), removeScraper(), refreshManifest(), addScraper(). Inject ScraperRepository dependency and handle coroutine scopes for async operations. Implement proper error handling and state updates.",
            "status": "done",
            "testStrategy": "Write unit tests for all ViewModel functions, verify state updates, test error scenarios, and mock ScraperRepository interactions"
          },
          {
            "id": 3,
            "title": "Build Scraper List Display Components",
            "description": "Create UI components for displaying scrapers with status indicators and management actions",
            "dependencies": [
              1,
              2
            ],
            "details": "Create ScraperListItem.kt composable showing scraper name, enabled/disabled status with Switch, last updated timestamp, and error state indicators. Implement ScraperStatusCard.kt displaying health metrics, response times, and content count. Add proper TV focus states, clickable actions, and visual feedback. Use Card components with appropriate elevation and colors for TV UI. Handle empty states when no scrapers are configured.",
            "status": "done",
            "testStrategy": "Create snapshot tests for different scraper states, test focus behavior on list items, verify action callbacks"
          },
          {
            "id": 4,
            "title": "Create Add/Configure Scraper Dialogs",
            "description": "Implement dialogs for adding new scrapers and configuring existing ones with TV-optimized input",
            "dependencies": [
              2
            ],
            "details": "Create AddScraperDialog.kt with URL input field, validation logic, and TV-friendly keyboard input. Build ScraperConfigDialog.kt for editing scraper-specific settings including quality filters (480p/720p/1080p/4K), provider selection checkboxes, and sorting preferences. Implement confirmation dialogs for destructive actions. Use TvAlertDialog components with proper focus management and D-pad navigation between form fields.",
            "status": "done",
            "testStrategy": "Test dialog display/dismiss, input validation, form submission, and focus navigation between fields"
          },
          {
            "id": 5,
            "title": "Integrate Settings Persistence and Real-time Updates",
            "description": "Connect UI to database layer and implement real-time configuration updates",
            "dependencies": [
              3,
              4
            ],
            "details": "Wire up ViewModel functions to ScraperRepository methods for CRUD operations. Implement Flow collection in UI to observe database changes and update display in real-time. Add preference storage for default quality selection and auto-refresh settings using DataStore. Handle loading states with progress indicators and success/error messages with SnackBar. Ensure all configuration changes persist to ScraperManifestEntity and related tables. Test integration with existing database schema.",
            "status": "done",
            "testStrategy": "Write integration tests verifying database updates, test real-time UI updates when data changes, verify preferences persistence"
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-06-22T03:41:46.714Z",
      "updated": "2025-07-06T01:25:21.163Z",
      "description": "Tasks for master context"
    }
  }
}